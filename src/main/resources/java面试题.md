- String s1= "abc"

- String s2 = new String("abc")

  关于s1与s2的底层分析，[详见](https://www.jianshu.com/p/72b45340af72)

1. 四种引用

   - 强引用

     任何通过强引用所使用的对象不管系统资源有多紧张，java GC都不会主动回收具有强引用的对象。

   - 弱引用

     如果一个对象只具有弱引用，无论内存充足与否，java gc后对象如果只有弱引用将会被自动回收。

   - 软引用

     软引用在内存不足时才被回收，如果一个对象只具有软引用，java gc在内存充足的时候不会回收它，内存不足时才会被回收。

   - 虚引用

     java gc会把虚引用的对象放到引用队列里面，可用来在对象被回收时做额外的一些资源清理或事物回滚等处理，跟踪垃圾回收器

2. JDK与JRE

   - JDK

     java development kit 的简称，java开发工具包，提供了java的开发环境和运行环境。

   - JRE

     java runtime environment的简称，java运行环境，为java提供了所需环境。

   - `总结`
     具体来说，JDK包含了JRE，同时还包含了编译java源码的编译器javac，还包含了很多java程序调试和分析工具，简单来说：如果你需要运行java程序，只需安装JRE就可以了，如果你需要编写java程序，需要安装JDK。

3. 两个对象的hashCode()相同，则equals()也一定为true？

   不对，两个对象的hashCode()相同，equals()不一定true。

   通话与重地，这两个对象的hashCode()是相同的，但equals()不同。

4. String、StringBuffer、StringBuilder

   String声明的是`不可变对象`，每次操作都会生成`新的对象`，然后将指针指向新的String对象，而StringBuffer、StringBuilder可以在原有的对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用String。

   StringBuffer和StringBuilder最大的区别在于，StringBuffer是线程安全的，而StringBuilder是非线程安全的，但StringBuilder的性能却高于StringBuffer，所以在单线程环境下推荐使用StringBuilder，多线程环境下推荐使用StringBuffer。

5. `BIO`、`NIO`、`AIO`
   - `BIO`：Block IO同步阻塞式IO,就是我们平常使用的传统IO，它的特点是模式简单使用方便，并发处理能力低。
   - `NIO`：New IO 同步非阻塞IO,是传统IO的升级，客户端和服务器端通过Channel通讯，实现了多路复用。
   - `AIO`：Asynchronous IO是NIO的升级，也叫NIO2，实现了异步非阻塞IO，异步IO的操作基于事件与回调机制。

6. Collection和Collections有什么区别？

   - java.util.Collection是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在java类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承的接口有List和Set。
   - Collections是集合类的工具类，用于对集合中元素进行排序、搜索以及线程安全等各种操作。

7. HashMap和HashTable的区别

   - hashMap去掉了hashTable的contains的方法，但是加上了containsValue()和containsKey()方法。
   - hashTable同步的，而hashMap是非同步的，效率上比hashTable要高。
   - hashMap允许空键值，而hashTable不允许.

8. ArraysList和LinkedList的区别

   最明显的区别是ArraysList底层的数据结构是数组，支持随机访问，而LinkedList的底层数据结构是双向链表，不支持随机访问，使用下标访问一个元素，ArrayList的时间复杂度是O(1)，而LinkedList是O(n)。

9. ArrayList和Vector的区别

   - Vector是同步的，而ArrayList不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。
   - ArrayList比Vector快，它因为有同步，不会过载。
   - ArrayList更加通用，因为我们可以使用Collections工具类获取同步列表和只读列表。

10. 哪些集合类是线程安全的

    - vector：比arraysList多了个同步机制（线程安全），因为效率低，现在已经不太建议使用。
    - statck：堆栈类，先进后出。
    - hashTable：比hashmap多了个线程安全。
    - enumeration：枚举，相当于迭代器。

11. 为什么重写equals时必须重写hashCode方法？

    - hashCode：hashCode()的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希码表中的索引位置。hashCode()定义在JDK的Object.java中，这意味着java中的任何类都包含有hashCode()函数。
    - equals它的作用也是判断两个对象是否相等，如果对象重写了equals()方法，比较两个对象的内容是否相等；如果没有重写，比较两个对象的地址是否相同，等价于"=="。equals()定义在JDK的Object.java中，这意味着java中任何类都包含有equals()函数。
    - 对于两个相同的对象，如果重写了equals()方法，则认为它们的内容相等，如果没有重写hashCode()方法，则放入set中会有重复元素。

12. `序列化`与`反序列化`

    - 序列化：把java对象转换为字节序程。
    - 反序列化：把字节序列恢复为java对象的过程。

    - 对象序列化主要有两种用途：
      - 把对象的字节序列永久的保存在硬盘上，通常存放在一个文件中。（持久化对象）
      - 在网络上传送对象的字节序列（网络传输对象）







## JVM

1. jvm`内存模型`及其作用
   - 程序计数器：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令。
   - java虚拟机栈：用于存储局部变量表、操作数栈、动态链接、方法出口等信息。
   - 本地方法栈：与虚拟机栈的作用一样，只不过虚拟机栈是服务java方法的，而本地方法栈是为虚拟机调用Native方法服务的。
   - java堆：java虚拟机中内存最大的一块，是所有线程共享的，几乎所有的对象实例都在这里分配内存。
   - 方法区：用于存储已被虚拟机加载的类信息、常量、静态变量、即使编译后的代码等数据。
2. `深拷贝`和`浅拷贝`
   - 浅拷贝：只是增加了一个指针指向已存在的内存地址。
   - 深拷贝：增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存；使用深拷贝的情况下，释放内存的时候不会因为出现浅拷贝时释放同一个内存的错误。类比于`原型模式`
   - 浅复制：仅仅是指向被复制的内存地址，如果原地址发生改变，那么浅复制出来的对象也会相应的改变。
   - 深复制：在计算机中开辟一块新的内存地址用于存放复制的对象。

3. java的内存泄漏

   内存泄漏是指不再被使用的对象或者变量一直被占据在内存中。理论上来说，java是有GC垃圾回收机制的，也就是说，不再被使用的对象，会被GC自动回收掉，自动从内存中清除。但是，即使这样，java也会存在着内存泄漏的情况，java导致内存泄漏的原因很明确：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄漏的发生场景。

4. java中的引用类型

   - 强引用：发生gc的时候不会被回收。
   - 弱引用：有用但不是必须对象，在下次GC时被回收。
   - 软引用：有用但不是必须对象，在发生内存溢出之前被回收。
   - 虚引用：无法通过虚引用获得对象，用PathtomReference实现虚引用，虚引用的作用是在gc时返回一个通知。

5. 怎么判断对象是否可以被回收？

   垃圾收集器在做垃圾回收的时候，首先需要判定的就是那些内存是需要被回收的，哪些对象是存活的，哪些对象是死掉的。

   `引用计数法`：为每个对象创建一个引用计数，有对象引用时计数器+1，引用被释放时计数-1，当计数器为0时就可以被回收。它有一个`缺点`不能解决循环引用的问题。

   `可达性分析算法`：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是可以被回收的。

6. GC Roots

   - java虚拟机栈中对象的引用
   - 方法区中类静态变量的引用
   - 方法区中常量的引用
   - 本地方法栈中的JNI引用的对象

7. JVM中的垃圾回收算法

   - 标记-清除算法：标记无用对象，然后进行清除回收。

     缺点：效率不高，会产生垃圾碎片

   - 复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。

     缺点：内存使用率不高，只有原来的一半。

   - 标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。
   - 分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。

8. JVM中的垃圾回收器

9. 简述分代垃圾回收器是怎么工作的？

   分代回收器有两个分区：新生代和老年代，占比1：2。

   新生代使用的是复制算法，新生代有3个分区：Eden、To Survivor、From Survivor，它们默认占比8:1:1，它们的执行流程如下：

   - 将Eden + From Survivor存活的对象放入To Survivor区；
   - 清空Eden和From Survivor分区；
   - Eden + To Survivor存活对象放入 From Survivor。

   每次在From Survivor到To Survivior移动时都存活的对象，年龄+1，当年龄达到15（默认是15）时，升级为老年代。大对象直接进入老年代。

   老年代当空间占用到达某个值之后就会触发全局垃圾回收，一般使用标记整理的执行算法、。

10. 内存分配策略

    对象的内存分配通常是在java堆上分配（随着虚拟机优化技术的诞生，某些场景下也会栈上分配），对象主要分配在新生代的Eden区，如果启动了本地线程缓冲，将按照线程优先在TLAB上分配。少数情况下也会直接在老年代上分配。总的来说分配规则不是百分百固定的，其细节取决于哪一种垃圾收集器组合以及虚拟机相关参数有关。

    - 对象优先在Eden区分配

      多数情况下，对象都在新生代Eden区分配，当Eden去分配没有足够的空间进行分配时，虚拟机将会发起一次Minor GC；如果本次GC后还是没有足够的空间，则将启用分配担保机制在老年代中分配内存。

    - 大对象直接进入老年代
    - 长期存活对象将进入老年代





## 类加载机制

1. 简述类加载机制

   虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验，解析和初始化，最终形成可以被虚拟机直接使用的java类型。

2. JVM加载class文件的原理机制

   java中的所有类，都需要由类加载器装载到JVM中才能运行。类加载器本身也是一个类，而它的工作就是把class文件从硬盘读取到内存中。

   - 隐式装载：程序在运行过程中当碰到通过new等方式生成对象时，隐式调用类装载器加载对应的类到jvm中。
   - 显式装载：通过class.forname()等方法，显式加载需要的类。

   java类的加载是动态的，它并不会一次性将所有类全部加载后运行，而是保证程序运行的基础类完全加载到jvm中，至于其他类，则在需要的时候才加载。

3. 类装载执行过程

   类装载分为以下5个步骤：

   - 加载：根据查找路径找到相应的class文件然后导入；
   - 验证：检查加载的class文件的正确性；
   - 准备：给类中的静态变量分配内存空间；
   - 解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用可以理解为一个标识，而在直接引用中直接指向内存中的地址；
   - 初始化：对静态变量和静态代码块执行初始化工作。

4. 双亲委派模型

   如果一个类加载器收到了类加载请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试去加载类。

   当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加载。

5. JVM调优工具

   JDK自带很多监控工具，都位于JDK的bin目录下，其中最常用的是jconsole和jvisualvm这两款视图监控工具。

   - jconsole：用于对JVM中的内存、线程和类等进行监控。
   - jvisualvm：JDK自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc变化等。