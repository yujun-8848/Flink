- String s1= "abc"

- String s2 = new String("abc")

  关于s1与s2的底层分析，[详见](https://www.jianshu.com/p/72b45340af72)

1. 四种引用

   - 强引用

     任何通过强引用所使用的对象不管系统资源有多紧张，java GC都不会主动回收具有强引用的对象。

   - 弱引用

     如果一个对象只具有弱引用，无论内存充足与否，java gc后对象如果只有弱引用将会被自动回收。

   - 软引用

     软引用在内存不足时才被回收，如果一个对象只具有软引用，java gc在内存充足的时候不会回收它，内存不足时才会被回收。

   - 虚引用

     java gc会把虚引用的对象放到引用队列里面，可用来在对象被回收时做额外的一些资源清理或事物回滚等处理，跟踪垃圾回收器

2. JDK与JRE

   - JDK

     java development kit 的简称，java开发工具包，提供了java的开发环境和运行环境。

   - JRE

     java runtime environment的简称，java运行环境，为java提供了所需环境。

   - `总结`
     具体来说，JDK包含了JRE，同时还包含了编译java源码的编译器javac，还包含了很多java程序调试和分析工具，简单来说：如果你需要运行java程序，只需安装JRE就可以了，如果你需要编写java程序，需要安装JDK。

3. 两个对象的hashCode()相同，则equals()也一定为true？

   不对，两个对象的hashCode()相同，equals()不一定true。

   通话与重地，这两个对象的hashCode()是相同的，但equals()不同。

4. String、StringBuffer、StringBuilder

   String声明的是`不可变对象`，每次操作都会生成`新的对象`，然后将指针指向新的String对象，而StringBuffer、StringBuilder可以在原有的对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用String。

   StringBuffer和StringBuilder最大的区别在于，StringBuffer是线程安全的，而StringBuilder是非线程安全的，但StringBuilder的性能却高于StringBuffer，所以在单线程环境下推荐使用StringBuilder，多线程环境下推荐使用StringBuffer。

5. `BIO`、`NIO`、`AIO`
   - `BIO`：Block IO同步阻塞式IO,就是我们平常使用的传统IO，它的特点是模式简单使用方便，并发处理能力低。
   - `NIO`：New IO 同步非阻塞IO,是传统IO的升级，客户端和服务器端通过Channel通讯，实现了多路复用。
   - `AIO`：Asynchronous IO是NIO的升级，也叫NIO2，实现了异步非阻塞IO，异步IO的操作基于事件与回调机制。

6. Collection和Collections有什么区别？

   - java.util.Collection是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在java类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承的接口有List和Set。
   - Collections是集合类的工具类，用于对集合中元素进行排序、搜索以及线程安全等各种操作。

7. HashMap和HashTable的区别

   - hashMap去掉了hashTable的contains的方法，但是加上了containsValue()和containsKey()方法。
   - hashTable同步的，而hashMap是非同步的，效率上比hashTable要高。
   - hashMap允许空键值，而hashTable不允许.

8. ArraysList和LinkedList的区别

   最明显的区别是ArraysList底层的数据结构是数组，支持随机访问，而LinkedList的底层数据结构是双向链表，不支持随机访问，使用下标访问一个元素，ArrayList的时间复杂度是O(1)，而LinkedList是O(n)。

9. ArrayList和Vector的区别

   - Vector是同步的，而ArrayList不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。
   - ArrayList比Vector快，它因为有同步，不会过载。
   - ArrayList更加通用，因为我们可以使用Collections工具类获取同步列表和只读列表。

10. 哪些集合类是线程安全的

    - vector：比arraysList多了个同步机制（线程安全），因为效率低，现在已经不太建议使用。
    - statck：堆栈类，先进后出。
    - hashTable：比hashmap多了个线程安全。
    - enumeration：枚举，相当于迭代器。

11. 为什么重写equals时必须重写hashCode方法？

    - hashCode：hashCode()的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希码表中的索引位置。hashCode()定义在JDK的Object.java中，这意味着java中的任何类都包含有hashCode()函数。
    - equals它的作用也是判断两个对象是否相等，如果对象重写了equals()方法，比较两个对象的内容是否相等；如果没有重写，比较两个对象的地址是否相同，等价于"=="。equals()定义在JDK的Object.java中，这意味着java中任何类都包含有equals()函数。
    - 对于两个相同的对象，如果重写了equals()方法，则认为它们的内容相等，如果没有重写hashCode()方法，则放入set中会有重复元素。

12. `序列化`与`反序列化`

    - 序列化：把java对象转换为字节序程。
    - 反序列化：把字节序列恢复为java对象的过程。

    - 对象序列化主要有两种用途：
      - 把对象的字节序列永久的保存在硬盘上，通常存放在一个文件中。（持久化对象）
      - 在网络上传送对象的字节序列（网络传输对象）



## 集合

1. 常用的集合类有哪些？

   Map接口和Collection接口是所有集合框架的父接口：

   - Collection接口的子接口包括：Set接口和List接口
   - Map接口的实现类主要有：HashMap、TreeMap、HashTable、ConcurrentHashMap以及Properties等
   - Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等
   - List接口的实现类主要有：ArraysList、LinkedList、Stack以及Vector等

2. Collection

   1. List
      - Arraylist：Object数组，初始化容量大小为10
      - Vector：Object数组，初始化容量大小为10
      - LinkedList：双向循环链表
   2. Set
      - HashSet(无序，唯一)：基于HashMap实现的，底层采用HashMap来保存元素
      - LinkedHashSet：LinkedHashSet继承于HashSet，并且其内部是通过LinkedhashMap来实现的。
      - TreeSet(有序，唯一)：红黑树

3. Map

   - HashMap：JDK1.8之前HashMap由数组+链表组成，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突），JDK1.8以后再解决哈希冲突时，当链表长度大于8时，将链表转化为红黑树，以减少搜索时间
   - LinkedHashMap：LinkedHashMap继承自HashMap，所以它的底层仍然是基于拉链式散列结构，即有数组和链表或者红黑树组成。另外，LinkedHashMap在上面结构的基础上，增加了一条双向链表，使得上面的结果可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。
   - HashTable：数组+链表组成。继承Dictionary抽象类，实现Map接口，初始化容量大小为11
   - TreeMap：红黑树

4. 哪些集合类是线程安全的？

   - Vector：比ArrayList多了个synchronized(线程安全),因为效率较低，现在已经不太建议使用。
   - hashTable：就比hashMap多了个synchronized(线程安全)，不建议使用
   - `ConcurrentHashMap`：是java5中支持高并发、高吞吐量的线程安全HashMap实现。它由Segment数组和HashEntry数组结构组成。Segment数组在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键-值对数据。一个ConcurrentHashMap里面包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表的结构；一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素；每个Segment守护一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改的时候，必须首先获得它对应的Segment锁。

5. ArrayList和Vector的区别是什么？

   这两个类都实现了List接口（List接口继承了Collection接口），它们都是有序集合

   - 线程安全：Vector使用了Synchronized来实现线程同步，是线程安全的，而ArrayList是非线程安全的。
   - 性能：ArrayList在性能方面要优于Vector
   - 扩容：ArrayList和Vector都会根据实际的需要动态的调整容量，只不过在Vector扩容每次会增加一倍，而ArrayList只会增加50%。

6. 插入数据时，ArrayList、LinkedList、Vector谁速度较快？

   - ArrayList和Vector底层的实现都是使用数组方式来存储数据。数据元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢。
   - Vector中的方法由于加了synchronized修饰，因此Vector是线程安全容器，但是性能上较ArrayList差。
   - LinkedList使用的是双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但插入数据时只需要记录当前项的前后项即可，所以LinkedList插入速度快。

7. List和Set的区别

   - List、Set都是继承自Collection接口
   - List特点：一个有序（元素存入集合的顺序和取出顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常见的实现类有ArrayList、LinkedList、Vector。
   - Set特点：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set接口常用实现类是HashSet、LinkedHashSet已经TreeSet。
   - 另外List支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。

   Set和List的对比

   - Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。
   - List：和数组类似，List可以动态增长，查找元素效率高，插入元素效率低，因为会引起其他元素位置改变。

8. HashSet的实现原理

   HashSet是基于HashMap实现的，HashSet的值存放于HashMap的key上，HashMap的value统一为parent，因此HashSet的实现比较简单，相关HashSet的操作，基本上都是直接调用底层HashMap相关方法来完成，HashSet不允许重复值。

9. hashCode()与equals()的相关规定：
   - 如果两个对象相等，则hashcode一定相同（hashcode是jdk根据对象的地址或者字符串或者数字算出来的int类型的数值）
   - 两个对象相等，对两个equals方法返回true
   - 两个对象有相同的hashcode值，则它们也不一定相等（通话与重地）
   - equals方法被重写，则hashcode方法也必须被重写
   - hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）
   
10. == 与equals的区别，[详见](https://zhuanlan.zhihu.com/p/121603364)
    
    - 对于==，比较的是指是否相等
      - 如果作用于基本数据类型的变量，则直接比较其存储的值是否相等
      - 如果作用于引用类型的变量，则比较的是所指向的对象的地址是否相等
    - 对于equals方法，比较的是是否是同一个对象
      - 首先，equals不能作用于基本数据类型的变量
      - equals()方法存在于Object类中，如果没有重写equals()方法，调用equals()方法的效果其实和使用==效果一样，也是比较的是引用类型的变量所指向的对象地址，若重写了equals()方法，则比较的就是两个对象的值。
    
11. 说一下HashMap的实现原理？

    - HashMap概述：HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。
    - HashMap的数据结构：在java编程语言，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。
    - HashMap基于Hash算法实现的
      - 当我们往HashMap中put元素时，利用key的hashCode重新hash计算出当前对象元素在数组中的下标
      - 存储时，如果出现hash值相同的key，此时有两种情况：
        - 如果key相同，则覆盖原始值
        - 如果key不同（出现冲突），则将当前的key-value放入链表中
      - 获取时，直接找到hash值对应的下标，进一步判断key是否相同，从而找到对应值
      - 理解了以上过程就不难明白HashMap是如何解决hash冲突的问题，核心就是使用了数组的存储方式，然后将冲突的key的对象放入链表中，一旦发现冲突就在链表中做进一步的对比。
    - 在JDK1.8中对HashMap的实现做了优化，当链表中的节点数据超过八个之后，该链表会转为红黑树来提高查询效率，从原来的O(n)到O(logn)

12. HashMap的底层实现？HashMap在JDK1.7和JDK1.8中有哪些不同？

    - 数组的特点：寻找容易，插入和删除困难
    - 链表的特点：寻址容易，但插入和删除容易

    故我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做拉链法的方式可以解决哈希冲突。

    - JDK1.8之前
      - 采用的是`拉链法`(将链表和数组相结合)。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。

## JVM

1. jvm`内存模型`及其作用
   - 程序计数器：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令。
   - java虚拟机栈：用于存储局部变量表、操作数栈、动态链接、方法出口等信息。
   - 本地方法栈：与虚拟机栈的作用一样，只不过虚拟机栈是服务java方法的，而本地方法栈是为虚拟机调用Native方法服务的。
   - java堆：java虚拟机中内存最大的一块，是所有线程共享的，几乎所有的对象实例都在这里分配内存。
   - 方法区：用于存储已被虚拟机加载的类信息、常量、静态变量、即使编译后的代码等数据。
2. `深拷贝`和`浅拷贝`
   - 浅拷贝：只是增加了一个指针指向已存在的内存地址。
   - 深拷贝：增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存；使用深拷贝的情况下，释放内存的时候不会因为出现浅拷贝时释放同一个内存的错误。类比于`原型模式`
   - 浅复制：仅仅是指向被复制的内存地址，如果原地址发生改变，那么浅复制出来的对象也会相应的改变。
   - 深复制：在计算机中开辟一块新的内存地址用于存放复制的对象。

3. java的内存泄漏

   内存泄漏是指不再被使用的对象或者变量一直被占据在内存中。理论上来说，java是有GC垃圾回收机制的，也就是说，不再被使用的对象，会被GC自动回收掉，自动从内存中清除。但是，即使这样，java也会存在着内存泄漏的情况，java导致内存泄漏的原因很明确：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄漏的发生场景。

4. java中的引用类型

   - 强引用：发生gc的时候不会被回收。
   - 弱引用：有用但不是必须对象，在下次GC时被回收。
   - 软引用：有用但不是必须对象，在发生内存溢出之前被回收。
   - 虚引用：无法通过虚引用获得对象，用PathtomReference实现虚引用，虚引用的作用是在gc时返回一个通知。

5. 怎么判断对象是否可以被回收？

   垃圾收集器在做垃圾回收的时候，首先需要判定的就是那些内存是需要被回收的，哪些对象是存活的，哪些对象是死掉的。

   `引用计数法`：为每个对象创建一个引用计数，有对象引用时计数器+1，引用被释放时计数-1，当计数器为0时就可以被回收。它有一个`缺点`不能解决循环引用的问题。

   `可达性分析算法`：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是可以被回收的。

6. GC Roots

   - java虚拟机栈中对象的引用
   - 方法区中类静态变量的引用
   - 方法区中常量的引用
   - 本地方法栈中的JNI引用的对象

7. JVM中的垃圾回收算法

   - 标记-清除算法：标记无用对象，然后进行清除回收。

     缺点：效率不高，会产生垃圾碎片

   - 复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。

     缺点：内存使用率不高，只有原来的一半。

   - 标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。
   - 分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。

8. JVM中的垃圾回收器

9. 简述分代垃圾回收器是怎么工作的？

   分代回收器有两个分区：新生代和老年代，占比1：2。

   新生代使用的是复制算法，新生代有3个分区：Eden、To Survivor、From Survivor，它们默认占比8:1:1，它们的执行流程如下：

   - 将Eden + From Survivor存活的对象放入To Survivor区；
   - 清空Eden和From Survivor分区；
   - Eden + To Survivor存活对象放入 From Survivor。

   每次在From Survivor到To Survivior移动时都存活的对象，年龄+1，当年龄达到15（默认是15）时，升级为老年代。大对象直接进入老年代。

   老年代当空间占用到达某个值之后就会触发全局垃圾回收，一般使用标记整理的执行算法、。

10. 内存分配策略

    对象的内存分配通常是在java堆上分配（随着虚拟机优化技术的诞生，某些场景下也会栈上分配），对象主要分配在新生代的Eden区，如果启动了本地线程缓冲，将按照线程优先在TLAB上分配。少数情况下也会直接在老年代上分配。总的来说分配规则不是百分百固定的，其细节取决于哪一种垃圾收集器组合以及虚拟机相关参数有关。

    - 对象优先在Eden区分配

      多数情况下，对象都在新生代Eden区分配，当Eden去分配没有足够的空间进行分配时，虚拟机将会发起一次Minor GC；如果本次GC后还是没有足够的空间，则将启用分配担保机制在老年代中分配内存。

    - 大对象直接进入老年代
    - 长期存活对象将进入老年代





## 类加载机制

1. 简述类加载机制

   虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验，解析和初始化，最终形成可以被虚拟机直接使用的java类型。

2. JVM加载class文件的原理机制

   java中的所有类，都需要由类加载器装载到JVM中才能运行。类加载器本身也是一个类，而它的工作就是把class文件从硬盘读取到内存中。

   - 隐式装载：程序在运行过程中当碰到通过new等方式生成对象时，隐式调用类装载器加载对应的类到jvm中。
   - 显式装载：通过class.forname()等方法，显式加载需要的类。

   java类的加载是动态的，它并不会一次性将所有类全部加载后运行，而是保证程序运行的基础类完全加载到jvm中，至于其他类，则在需要的时候才加载。

3. 类装载执行过程

   类装载分为以下5个步骤：

   - 加载：根据查找路径找到相应的class文件然后导入；
   - 验证：检查加载的class文件的正确性；
   - 准备：给类中的静态变量分配内存空间；
   - 解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用可以理解为一个标识，而在直接引用中直接指向内存中的地址；
   - 初始化：对静态变量和静态代码块执行初始化工作。

4. 双亲委派模型

   如果一个类加载器收到了类加载请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试去加载类。

   当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加载。

5. JVM调优工具

   JDK自带很多监控工具，都位于JDK的bin目录下，其中最常用的是jconsole和jvisualvm这两款视图监控工具。

   - jconsole：用于对JVM中的内存、线程和类等进行监控。
   - jvisualvm：JDK自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc变化等。





## 数据库

1. 主键、外键、超键、候选键
   - 主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值null。
   - 外键：在一个表中存在的另一个表的主键称此表的外键。
   - 

2. 什么是存储过程？用什么来调用？

   存储过程是一个预编译的sql语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次sql，使用存储过程比单纯sql语句执行要快。

   调用：

   - 可以用一个命令对象来调用存储过程。
   - 可以供外部程序调用，比如java程序。

3. 存储过程的优缺点

   优点：

   - 存储过程是预编译过的，执行效率高。
   - 存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。
   - 安全性高，执行存储过程需要有一定权限的用户。
   - 存储过程可以重复使用，可减少数据库开发人员的工作量。

   缺点：

   - 移植性差。

4. 什么是临时表，临时表什么时候删除？

   - 临时表可以手动删除。
   - 临时表只在当前连接可见，当关闭连接时，mysql会自动删除表并释放所有空间。因此在不同的连接中可以创建同名的临时表，并且操作属于本连接的临时表。
   - 创建临时表的语法与创建表语法类似，不同之处是增加关键字`TEMPORARY`。

5. 非关系型数据库和关系型数据库区别，优势比较？

   `非关系型数据库的优势`(HBase、Redis、MongoDB、Couchbase、LevelDB)：

   - 性能：NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。
   - 可扩展性：同样也是因为基于键值对，数据之间没有耦合性，所以非常容易扩展。

   `关系型数据库的优势`（mysql、SQL Sever、Oracle、Sybase、DB2、PostgreSQL）：

   - 复杂查询：可以用SQL语句方便的在一个表已经多个表之间做非常复杂的数据查询。
   - 事物支持：使得对于安全性能很高的数据访问要求得以实现。

   `其他`：

   - 对于这两类数据库，对方的优势就是自己的弱势，反之亦然。
   - NOSQL数据库慢慢开始具备SQL数据库的一些复杂查询功能，比如MongoDB。
   - 对于事务的支持也可以用一些系统级的原子操作来实现，例如乐观锁之类的方法来曲线救国，比如Redis set nx。

6. 数据库范式
   - 第一范式：（确保每列保存原子性）所有字段值都是不可分解的原子值。
   - 第二范式：（确保表中的每列都和主键相关）在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。
   - 第三范式：（确保每列都和主键列直接相关，而不是间接相关）数据表中的每一列数据都和主键直接想关，而不能间接相关。第三范式需要确保数据表中的每一列数据都和主键直接想关，而不能间接相关。

7. 什么是索引

   数据库索引，是数据库管理系统中一个排序的数据结构，索引的实现通常使用B树及其B+树。

   在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。

8. 索引的作用？它的优缺点？

   `索引的作用`：

   协助快速查询、更新数据库表中的数据。

   为表设置索引要付出代价的：

   - 增加了数据库的存储空间
   - 在插入和修改数据时要花费较多的时间（因为索引也要随之变动）

   `索引的优点`：

   - 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
   - 可以大大加快数据的检索速度，这也是创建索引的最主要原因。
   - 可以加速表和表之间连接，特别是在实现数据的参考完整性方面特别有意义。
   - 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。
   - 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统性能。

    `索引的缺点`：

   - 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。
   - 索引需要占物理空间，除了数据表占数据空间外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。
   - 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。

9. 什么是`事务`

   事务是对数据库中一系列操作进行统一回滚或者提交的操作，主要用来保证数据的完整性和一致性。

10. 事务四大特性(ACID)原子性、一致性、隔离性、持久性

    `原子性`

    原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。

    `一致性`

    事务开始前和结束后，数据库的完整性约束没有被破坏。比如A向B转账，不可能A扣了钱，B却没有收到。

    `隔离性`

    隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启一个事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。

    `持久性`

    持久性是指一事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失对提交事务的操作。

11. 事务的并发？事务隔离级别，每个级别会引发什么问题，mysql默认是哪个级别？

    从理论上来说，事务应该彼此完全隔离，以避免并发事务所导致的问题，然而，那样会对性能产生极大的影响，因为事务必须按顺序运行，在实际开发中，为了提升性能，事务会以较低的隔离级别运行，事务的隔离级别可以通过隔离事务属性指定。

    `事务的并发问题`

    - 脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据。

    - 不可重复读：事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。

    - 幻读：幻读解决了不重复读，保证了同一个事务里，查询的结果都是事务开始时的状态（一致性）。

      例如：事务T1对一个表中所有的行的某个数据项做了从“1”修改“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给了数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有跟没有修改一样，其实这行就是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。

    `小结`

    不可重复读和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或者删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。

    `事务的隔离级别`

    - 读未提交：另一个事务修改了数据，但尚未提交，而本事务中的SELECT会读到这些未被提交的数据脏读。
    - 不可重复读：事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。
    - 可重复读：在同一事务里，SELECT的结果是事务开始时时间点的状态，因此，同样的SELECT操作读到结果会是一致的。
    - 串行化：最高的隔离级别，在这个隔离级别下，不会产生任何异常，并发的事务，就像事务是在一个个按照顺序执行一样。

    

    

    