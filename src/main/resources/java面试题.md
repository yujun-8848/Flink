- String s1= "abc"

- String s2 = new String("abc")

  关于s1与s2的底层分析，[详见](https://www.jianshu.com/p/72b45340af72)

1. 四种引用

   - `强引用`

     任何通过强引用所使用的对象不管系统资源有多紧张，java GC都不会主动回收具有强引用的对象。

   - `弱引用`

     如果一个对象只具有弱引用，无论内存充足与否，java gc后对象如果只有弱引用将会被自动回收。

   - `软引用`

     软引用在内存不足时才被回收，如果一个对象只具有软引用，java gc在内存充足的时候不会回收它，内存不足时才会被回收。

   - `虚引用`

     java gc会把虚引用的对象放到引用队列里面，可用来在对象被回收时做额外的一些资源清理或事物回滚等处理，跟踪垃圾回收器

2. JDK与JRE

   - JDK

     java development kit 的简称，java开发工具包，提供了java的开发环境和运行环境。

   - JRE

     java runtime environment的简称，java运行环境，为java提供了所需环境。

   - `总结`
     具体来说，JDK包含了JRE，同时还包含了编译java源码的编译器javac，还包含了很多java程序调试和分析工具，简单来说：如果你需要运行java程序，只需安装JRE就可以了，如果你需要编写java程序，需要安装JDK。

3. 两个对象的hashCode()相同，则equals()也一定为true？

   不对，两个对象的hashCode()相同，equals()不一定true。

   通话与重地，这两个对象的hashCode()是相同的，但equals()不同。

4. String、StringBuffer、StringBuilder

   String声明的是`不可变对象`，每次操作都会生成`新的对象`，然后将指针指向新的String对象，而StringBuffer、StringBuilder可以在原有的对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用String。

   StringBuffer和StringBuilder最大的区别在于，StringBuffer是线程安全的，而StringBuilder是非线程安全的，但StringBuilder的性能却高于StringBuffer，所以在单线程环境下推荐使用StringBuilder，多线程环境下推荐使用StringBuffer。

5. `BIO`、`NIO`、`AIO`
   
   - `BIO`：Block IO同步阻塞式IO,就是我们平常使用的传统IO，它的特点是模式简单使用方便，并发处理能力低。
   - `NIO`：New IO 同步非阻塞IO,是传统IO的升级，客户端和服务器端通过Channel通讯，实现了多路复用。
- `AIO`：Asynchronous IO是NIO的升级，也叫NIO2，实现了异步非阻塞IO，异步IO的操作基于事件与回调机制。
   
6. Collection和Collections有什么区别？

   - java.util.Collection是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在java类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承的接口有List和Set。
   - Collections是集合类的工具类，用于对集合中元素进行排序、搜索以及线程安全等各种操作。

7. HashMap和HashTable的区别

   - hashMap去掉了hashTable的contains的方法，但是加上了containsValue()和containsKey()方法。
   - hashTable同步的，而hashMap是非同步的，效率上比hashTable要高。
   - hashMap允许空键值，而hashTable不允许.

8. ArraysList和LinkedList的区别

   最明显的区别是ArraysList底层的数据结构是数组，支持随机访问，而LinkedList的底层数据结构是双向链表，不支持随机访问，使用下标访问一个元素，ArrayList的时间复杂度是O(1)，而LinkedList是O(n)。

9. ArrayList和Vector的区别

   - Vector是同步的，而ArrayList不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。
   - ArrayList比Vector快，它因为有同步，不会过载。
   - ArrayList更加通用，因为我们可以使用Collections工具类获取同步列表和只读列表。

10. 哪些集合类是线程安全的

    - vector：比arraysList多了个同步机制（线程安全），因为效率低，现在已经不太建议使用。
    - statck：堆栈类，先进后出。
    - hashTable：比hashmap多了个线程安全。
    - enumeration：枚举，相当于迭代器。

11. 为什么重写equals时必须重写hashCode方法？

    - hashCode：hashCode()的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希码表中的索引位置。hashCode()定义在JDK的Object.java中，这意味着java中的任何类都包含有hashCode()函数。
    - equals它的作用也是判断两个对象是否相等，如果对象重写了equals()方法，比较两个对象的内容是否相等；如果没有重写，比较两个对象的地址是否相同，等价于"=="。equals()定义在JDK的Object.java中，这意味着java中任何类都包含有equals()函数。
    - 对于两个相同的对象，如果重写了equals()方法，则认为它们的内容相等，如果没有重写hashCode()方法，则放入set中会有重复元素。

12. `序列化`与`反序列化`

    - 序列化：把java对象转换为字节序程。
    - 反序列化：把字节序列恢复为java对象的过程。

    - 对象序列化主要有两种用途：
      - 把对象的字节序列永久的保存在硬盘上，通常存放在一个文件中。（持久化对象）
      - 在网络上传送对象的字节序列（网络传输对象）



## 集合

1. 常用的集合类有哪些？

   Map接口和Collection接口是所有集合框架的父接口：

   - Collection接口的子接口包括：Set接口和List接口
   - Map接口的实现类主要有：HashMap、TreeMap、HashTable、ConcurrentHashMap以及Properties等
   - Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等
   - List接口的实现类主要有：ArraysList、LinkedList、Stack以及Vector等

2. Collection

   1. List
      - Arraylist：Object数组，初始化容量大小为10
      - Vector：Object数组，初始化容量大小为10
      - LinkedList：双向循环链表
   2. Set
      - HashSet(无序，唯一)：基于HashMap实现的，底层采用HashMap来保存元素
      - LinkedHashSet：LinkedHashSet继承于HashSet，并且其内部是通过LinkedhashMap来实现的。
      - TreeSet(有序，唯一)：红黑树

3. Map

   - HashMap：JDK1.8之前HashMap由数组+链表组成，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突），JDK1.8以后再解决哈希冲突时，当链表长度大于8时，将链表转化为红黑树，以减少搜索时间
   - LinkedHashMap：LinkedHashMap继承自HashMap，所以它的底层仍然是基于拉链式散列结构，即有数组和链表或者红黑树组成。另外，LinkedHashMap在上面结构的基础上，增加了一条双向链表，使得上面的结果可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。
   - HashTable：数组+链表组成。继承Dictionary抽象类，实现Map接口，初始化容量大小为11
   - TreeMap：红黑树

4. 哪些集合类是线程安全的？

   - Vector：比ArrayList多了个synchronized(线程安全),因为效率较低，现在已经不太建议使用。
   - hashTable：就比hashMap多了个synchronized(线程安全)，不建议使用
   - `ConcurrentHashMap`：是java5中支持高并发、高吞吐量的线程安全HashMap实现。它由Segment数组和HashEntry数组结构组成。Segment数组在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键-值对数据。一个ConcurrentHashMap里面包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表的结构；一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素；每个Segment守护一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改的时候，必须首先获得它对应的Segment锁。

5. ArrayList和Vector的区别是什么？

   这两个类都实现了List接口（List接口继承了Collection接口），它们都是有序集合

   - 线程安全：Vector使用了Synchronized来实现线程同步，是线程安全的，而ArrayList是非线程安全的。
   - 性能：ArrayList在性能方面要优于Vector
   - 扩容：ArrayList和Vector都会根据实际的需要动态的调整容量，只不过在Vector扩容每次会增加一倍，而ArrayList只会增加50%。

6. 插入数据时，ArrayList、LinkedList、Vector谁速度较快？

   - ArrayList和Vector底层的实现都是使用数组方式来存储数据。数据元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢。
   - Vector中的方法由于加了synchronized修饰，因此Vector是线程安全容器，但是性能上较ArrayList差。
   - LinkedList使用的是双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但插入数据时只需要记录当前项的前后项即可，所以LinkedList插入速度快。

7. List和Set的区别

   - List、Set都是继承自Collection接口
   - List特点：一个有序（元素存入集合的顺序和取出顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常见的实现类有ArrayList、LinkedList、Vector。
   - Set特点：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set接口常用实现类是HashSet、LinkedHashSet已经TreeSet。
   - 另外List支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。

   Set和List的对比

   - Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。
   - List：和数组类似，List可以动态增长，查找元素效率高，插入元素效率低，因为会引起其他元素位置改变。

8. HashSet的实现原理

   HashSet是基于HashMap实现的，HashSet的值存放于HashMap的key上，HashMap的value统一为parent，因此HashSet的实现比较简单，相关HashSet的操作，基本上都是直接调用底层HashMap相关方法来完成，HashSet不允许重复值。

9. hashCode()与equals()的相关规定：
   - 如果两个对象相等，则hashcode一定相同（hashcode是jdk根据对象的地址或者字符串或者数字算出来的int类型的数值）
   - 两个对象相等，对两个equals方法返回true
   - 两个对象有相同的hashcode值，则它们也不一定相等（通话与重地）
   - equals方法被重写，则hashcode方法也必须被重写
   - hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）
   
10. == 与equals的区别，[详见](https://zhuanlan.zhihu.com/p/121603364)
    
    - 对于==，比较的是指是否相等
      - 如果作用于基本数据类型的变量，则直接比较其存储的值是否相等
      - 如果作用于引用类型的变量，则比较的是所指向的对象的地址是否相等
    - 对于equals方法，比较的是是否是同一个对象
      - 首先，equals不能作用于基本数据类型的变量
      - equals()方法存在于Object类中，如果没有重写equals()方法，调用equals()方法的效果其实和使用==效果一样，也是比较的是引用类型的变量所指向的对象地址，若重写了equals()方法，则比较的就是两个对象的值。
    
11. 说一下HashMap的实现原理？

    - HashMap概述：HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。
    - HashMap的数据结构：在java编程语言，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。
    - HashMap基于Hash算法实现的
      - 当我们往HashMap中put元素时，利用key的hashCode重新hash计算出当前对象元素在数组中的下标
      - 存储时，如果出现hash值相同的key，此时有两种情况：
        - 如果key相同，则覆盖原始值
        - 如果key不同（出现冲突），则将当前的key-value放入链表中
      - 获取时，直接找到hash值对应的下标，进一步判断key是否相同，从而找到对应值
      - 理解了以上过程就不难明白HashMap是如何解决hash冲突的问题，核心就是使用了数组的存储方式，然后将冲突的key的对象放入链表中，一旦发现冲突就在链表中做进一步的对比。
    - 在JDK1.8中对HashMap的实现做了优化，当链表中的节点数据超过八个之后，该链表会转为红黑树来提高查询效率，从原来的O(n)到O(logn)

12. HashMap的底层实现？HashMap在JDK1.7和JDK1.8中有哪些不同？

    - 数组的特点：寻找容易，插入和删除困难
    - 链表的特点：寻址容易，但插入和删除容易

    故我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做拉链法的方式可以解决哈希冲突。

    - JDK1.8之前
      - 采用的是`拉链法`(将链表和数组相结合)。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。
    - JDK1.8之后
      - JDK1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8时），将链表转化为红黑树，以减少搜索时间。
    
13. JDK1.7 VS JDK1.8

    JDK1.8主要解决或者优化了以下问题：

    - resize扩容优化
    - 引入了红黑树，目的是避免单条链表过长而影响查询效率
    - 解决了多线程死循环问题，但仍是非线程安全的，多线程时可能会造成数据丢失问题。

14. HashMap的扩容操作是怎么实现的？

    - 在jdk1.8中，resize方法是在hashmap中的键值对大于阈值时或者初始化时，就调用resize方法进行扩容。
    - 每次扩展的时候，都扩展2倍。
    - 扩展后Node对象的位置要么在原位置，要么移动到原偏移量两倍的位置。
    - 在putVal()中，我们看到在这个函数里面使用到了2次resize()方法，resize()方法表示的在进行第一次初始化时会对其进行扩容，或者当该数组的实际大小大于其临界值（第一次为12），这个时候在扩容的同时也会伴随桶上面的元素进行重新分发，这也是JDK1.8版本的一个优化地方，在1.7中，扩容之后需要重新去计算其hash值，根据hash值对其进行分发，但在1.8版本中，则是根据在同一桶的位置中进行判断（e.hash & oldCap）是否为0，重新进行hash分配后，该元素的位置要么停留在原来的位置，要么移动到原始位置+原数组大小

15. 什么是哈希

    hash,一般翻译为“`散列`”，也有直接音译为“哈希”的，hash就是指使用哈希算法把任意长度的二进制映射为固定长度的较小的二进制值，这个较小的二进制值叫做哈希值。

16. 什么是`哈希冲突`

    当两个不同的输入值，根据同一散列函数计算出相同的散列值的现场，我们就把它叫做哈希碰撞

17. HashMap的数据结构
    - 在java中，保存数据有两种比较简单的数据结构，数组和链表。
      - 数组的特点：寻址容易，插入和删除困难
      - 链表的特点：寻址困难，插入和删除容易
    - 所以我们将数组和链表结合在一起，发挥两者各自的优势，就可以使用两种方式：链地址法和开发地址法可以解决哈希冲突。
    - 链表法就是将相同hash值的对象组织成一个链表放在hash值对应的槽位
    - 开发地址法是通过一个探测算法，当某个槽位已经被占据的情况下继续查找下一个可以使用的槽位

18. hash()函数

    如果使用hashCode取余，那么相当于参与运算的只有hashCode的低位，高位是没有起到任何作用的，所以我们的思路就是让hashCode取值出的高位也参与运算，进一步降低hash碰撞的概率，使得数据分布更平均，我们称之为扰动。

    ```java
    static final int hash(Object key){
        int h;
        //与自己右移16位进行异或运算（高低位异或）
        return (key == null)? 0:(h == key.hashCode()) ^ (h >>> 16);
    }
    ```

19. 能否使用任何类作为Map的key?

    可以使用任何类作为Map的key，然而在使用之前，需要考虑以下几点：

    - 如果类重写了equals()方法，也应该重写hashCode()方法。
    - 类的所有实例需要遵循与equals()和hashCode()相关的规则。

20. 如果使用Object作为HashMap的key，应该怎么办？

    重写`hashCode()`和`equals()`方法

    - 重写`hashCode()`是因为需要计算存储数据的存储位置，需要注意不要试图从散列码计算中排除一个对象的关键部分来提高性能，这样虽然能更快但是可能会导致更多的hash碰撞；
    - 重写`equals()`方法，需要遵守自反性、对称性、传递性、一致性以及对于任何非Null的引用值x，x.equals(null)必须返回false的这几个特性，目的是为了保证key在哈希表中的唯一性。

21. HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？

    `hashCode()`方法返回的是int整数类型，其范围是-(2^31)~(2^31 -1)，而hashMap的容量范围是在16（默认值）~2^30，hashmap通常情况下是取不到最大值的，并且设备上也难以提供这么多的存储空间，从而导致通过`hashCode()`计算出的哈希值可能不在数组大小范围内，进而无法匹配存储位置。

    - 解决方案：
      - HashMap自己实现了自己的`hash()`方法，通过2次扰动使得它自己的哈希值高低位自行进行异或运算，降低哈希碰撞概率也使得数据分布更平均
      - 在保证数组长度为2的幂次方的时候，使用`hash()`运算之后的值与运算(&)（数组长度-1）来获取数组下标的方式进行存储，这样一来是比取余操作更有效率，二来也是因为只有当数组长度为2的幂次方时，h&(length -1)才等价于h %length，三来解决了“哈希值与数组方法大小范围不匹配”的问题。

22. HashMap的长度为什么是2的幂次方

    - 为了能让hashMap存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀，每个链表/红黑树长度大致相同

    - 算法如何设计

      - hash % length == hash &(length -1)的前提是length是2的n次方
      - 采用二进制位操作&，相对于%能够提高运算效率。

    - 为什么是两次扰动

      这样就是加大哈希值低位随机性，使得分布更均匀，从而提高数组存储下标位置的随机性和均匀性，最终减少hash冲突，两次就够了，已经达到了高位低位同时参与运算的目的。

23. HashMap与HashTable有什么区别

    - 线程安全：HashMap是非线程安全的，HashTable是线程安全的，HashTable内部的方法基本都经过`synchronized`修饰
    - 效率：hashMap高很多
    - 对Null key 和Null value的支持：HashMap中，Null可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为Null。但是在HashTable中put进的键值只要有一个null，直接抛异常。
    - 初始容量大小和每次扩充容量大小的不同：
      - 创建时，初始化容量，HashTable的默认初始化大小为11，之后每次扩充，容量变为原来的2n+1。HashMap默认的初始化大小为16，之后每次扩充，容量变为原来的2倍。
      - 创建时如果给定容量初始值，HashTable会直接使用你给定的大小，而HashMap会将其扩充为2的幂次方大小。

24. 什么是TreeMap

    - TreeMap是一个有序的key-value集合，它是通过红黑树实现的
    - TreeMap基于红黑树实现，该映射根据其键的自然顺序进行排序，或者创建映射时提供的Comparator进行排序。
    - TreeMap是线程非同步的

25. 如何决定使用HashMap还是TreeMap？

    对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的Key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序Key的遍历。

26. HashMap和ConcurrentHashMap的区别

    - ConcurrentHashMap对整个桶数组进行了分割片段（Segment），然后在每一个分段上都用lock锁进行保护，相对于HashTable的synchronized锁的粒度更精细了一些，并发性能更好，而HashMap没有锁进制，不是线程安全的（JDK1.8之后ConcurrentHashMap启用了一种全新的方式是实现，利用CAS算法）
    - HashMap的键值对允许有Null，但是ConcurrentHashMap不允许。

27. ConcurrentHashMap和HashTable的区别

    - ConcurrentHashMap和HashTable的区别主要体现在实现线程安全的方式上不同。
      - 底层数据结构：JDK1.7的ConcurrentHashMap底层采用`分段的数组`+`链表`实现，JDK1.8采用的数据结构跟HashMap1.8的结构一样，`数组+链表+红黑树`。HashTable和JDK1.8之前的HashMap的底层数据结构采用数组+链表，数组和HashMap的主体，链表则是主要为了解决哈希冲突而存在的。

    - 实现线程安全的方式：
      - 在`JDK1.7`的时候，ConcurrentHashMap(分段锁)对整个桶数组进行了分割片段（Segment），每一把锁只锁容器其中一部分数据，多线程访问容器里面不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配16个Segment，比HashTable效率提高16倍），到了`JDK1.8`的时候已经摒弃了`Segment`的概念，而是直接用`Node数组+链表+红黑树`的数据结构来实现，并发控制使用synchronized和CAS来操作，整体看起来就像是优化过且线程安全的HashMap。
      - HashTable（`同一把锁`）：使用synchronized来保证线程安全，效率非常低。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用put添加元素，另一个线程不能使用put添加元素，也不能使用get，竞争会越来越激烈效率越低。

## JVM

1. jvm`内存模型`及其作用
   - 程序计数器：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令。
   - java虚拟机栈：用于存储局部变量表、操作数栈、动态链接、方法出口等信息。
   - 本地方法栈：与虚拟机栈的作用一样，只不过虚拟机栈是服务java方法的，而本地方法栈是为虚拟机调用Native方法服务的。
   - java堆：java虚拟机中内存最大的一块，是所有线程共享的，几乎所有的对象实例都在这里分配内存。
   - 方法区：用于存储已被虚拟机加载的类信息、常量、静态变量、即使编译后的代码等数据。
2. `深拷贝`和`浅拷贝`
   - 浅拷贝：只是增加了一个指针指向已存在的内存地址。
   - 深拷贝：增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存；使用深拷贝的情况下，释放内存的时候不会因为出现浅拷贝时释放同一个内存的错误。类比于`原型模式`
   - 浅复制：仅仅是指向被复制的内存地址，如果原地址发生改变，那么浅复制出来的对象也会相应的改变。
   - 深复制：在计算机中开辟一块新的内存地址用于存放复制的对象。

3. java的内存泄漏

   内存泄漏是指不再被使用的对象或者变量一直被占据在内存中。理论上来说，java是有GC垃圾回收机制的，也就是说，不再被使用的对象，会被GC自动回收掉，自动从内存中清除。但是，即使这样，java也会存在着内存泄漏的情况，java导致内存泄漏的原因很明确：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄漏的发生场景。

4. java中的引用类型

   - 强引用：发生gc的时候不会被回收。
   - 弱引用：有用但不是必须对象，在下次GC时被回收。
   - 软引用：有用但不是必须对象，在发生内存溢出之前被回收。
   - 虚引用：无法通过虚引用获得对象，用PathtomReference实现虚引用，虚引用的作用是在gc时返回一个通知。

5. 怎么判断对象是否可以被回收？

   垃圾收集器在做垃圾回收的时候，首先需要判定的就是那些内存是需要被回收的，哪些对象是存活的，哪些对象是死掉的。

   `引用计数法`：为每个对象创建一个引用计数，有对象引用时计数器+1，引用被释放时计数-1，当计数器为0时就可以被回收。它有一个`缺点`不能解决循环引用的问题。

   `可达性分析算法`：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是可以被回收的。

6. GC Roots

   - java虚拟机栈中对象的引用
   - 方法区中类静态变量的引用
   - 方法区中常量的引用
   - 本地方法栈中的JNI引用的对象

7. JVM中的垃圾回收算法

   - 标记-清除算法：标记无用对象，然后进行清除回收。

     缺点：效率不高，会产生垃圾碎片

   - 复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。

     缺点：内存使用率不高，只有原来的一半。

   - 标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。
   - 分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。

8. JVM中的垃圾回收器

9. 简述分代垃圾回收器是怎么工作的？

   分代回收器有两个分区：新生代和老年代，占比1：2。

   新生代使用的是复制算法，新生代有3个分区：Eden、From Survivor、To Survivor，它们默认占比8:1:1，它们的执行流程如下：

   - 将Eden + From Survivor存活的对象放入To Survivor区；
   - 清空Eden和From Survivor分区；
   - Eden + To Survivor存活对象放入 From Survivor。

   每次在From Survivor到To Survivior移动时都存活的对象，年龄+1，当年龄达到15（默认是15）时，升级为老年代。大对象直接进入老年代。

   老年代当空间占用到达某个值之后就会触发全局垃圾回收，一般使用标记整理的执行算法。

10. 内存分配策略

    对象的内存分配通常是在java堆上分配（随着虚拟机优化技术的诞生，某些场景下也会栈上分配），对象主要分配在新生代的Eden区，如果启动了本地线程缓冲，将按照线程优先在TLAB上分配。少数情况下也会直接在老年代上分配。总的来说分配规则不是百分百固定的，其细节取决于哪一种垃圾收集器组合以及虚拟机相关参数有关。

    - 对象优先在Eden区分配

      多数情况下，对象都在新生代Eden区分配，当Eden区分配没有足够的空间进行分配时，虚拟机将会发起一次Minor GC；如果本次GC后还是没有足够的空间，则将启用分配担保机制在老年代中分配内存。

    - 大对象直接进入老年代
    - 长期存活对象将进入老年代





## 类加载机制

1. 简述类加载机制

   虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验，解析和初始化，最终形成可以被虚拟机直接使用的java类型。

2. JVM加载class文件的原理机制

   java中的所有类，都需要由类加载器装载到JVM中才能运行。类加载器本身也是一个类，而它的工作就是把class文件从硬盘读取到内存中。

   - 隐式装载：程序在运行过程中当碰到通过new等方式生成对象时，隐式调用类装载器加载对应的类到jvm中。
   - 显式装载：通过class.forname()等方法，显式加载需要的类。

   java类的加载是动态的，它并不会一次性将所有类全部加载后运行，而是保证程序运行的基础类完全加载到jvm中，至于其他类，则在需要的时候才加载。

3. 类装载执行过程

   类装载分为以下5个步骤：

   - 加载：根据查找路径找到相应的class文件然后导入；
   - 验证：检查加载的class文件的正确性；
   - 准备：给类中的静态变量分配内存空间；
   - 解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用可以理解为一个标识，而在直接引用中直接指向内存中的地址；
   - 初始化：对静态变量和静态代码块执行初始化工作。

4. 双亲委派模型

   如果一个类加载器收到了类加载请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试去加载类。

   当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加载。

5. JVM调优工具

   JDK自带很多监控工具，都位于JDK的bin目录下，其中最常用的是jconsole和jvisualvm这两款视图监控工具。

   - jconsole：用于对JVM中的内存、线程和类等进行监控。
   
   - jvisualvm：JDK自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc变化等。
   
     

## 多线程

1. 什么是线程和进程

   - 进程：在操作系统中能够独立运行，并且作为资源分配的基本单位。它表示运行中的程序。系统运行一个程序就是一个进程从创建、运行到消亡的过程。
   - 线程：是一个比进程更小的执行单位，能够完成进程中的一个功能，也被称为轻量级进程。一个进程在其执行的过程中可以产生多个线程。

   - 线程与进程不同的是：同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序技术器、虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小的多。

2. 什么是线程

   线程时操作系统能够进行运算调度的最小单位，它被包含在进程中，是进程中的实际运作单位。

3. 进程和线程的区别

   线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同任务。不同进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。别把它和栈内存搞混，每个线程都拥有单独的栈内存用来存储本地数据。

4. Thread类中的start()和run()方法有什么区别

   start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。

5. 什么是线程安全

   如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。一个线程安全的计数器类的同一实例对象在被多个线程使用的情况下也不会出现计算失误。

6. 什么是`ThreadLocal`变量

   ThreadLocal使用场合主要解决多线程中数据数据因并发产生不一致问题。`ThreadLocal`为每个线程中并发访问的数据提供一个副本，通过访问副本来运行业务，这样的结果是耗费内存，但大大减少了线程同步所带来的性能消耗，也减少了线程并发控制的复杂度。

   ThreadLocal不能使用原子类型，只能使用Object类型，ThreadLocal的使用比synchronized要简单的多。

   ThreadLocal和synchonized都用于解决多线程并发访问。但是ThreadLocal与synchonized有本质区别，synchonized是利用锁的机制，是变量或代码块在某一时刻只能被一个线程访问。而ThreadLocal为每一个线程都提供了变量副本，使得每个线程在某一时间访问到的并不是同一个对象，这样就隔离了多个线程对数据的共享，而synchronized却正好相反，它用于在多个线程间通信时能够获得数据共享。

7. java中堆和栈有什么不同

   每个线程都有自己的栈内存，用于存储本地变量，方法参数和栈调用，一个线程中存储的变量对其它线程是不可见的。而堆是所有线程共享的一片公用内存区域。对象都在堆里创建，为了提升效率线程会从堆中弄一个缓存到自己的栈中，如果多线程使用该变量就可能会引发问题，这时`volatile`变量就可以发挥作用了，它要求线程从主存中读取变量的值。

8. 什么是线程池？为什么使用它？

   创建线程要花费昂贵的资源和时间，如果任务来了才创建那么相应时间会变长，而且一个进程能创建的线程数有限。为了避免这些问题，在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程。

9. 如何避免死锁

   死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。这是一个严重的问题，因为死锁会让你的程序挂起无法完成任务。

   死锁发生必须满足的四个条件：

   - 互斥条件：一个资源每次只能被一个进程使用
   - 请求与保持：一个进程因请求资源而阻塞时，对已获得的资源保持不放
   - 不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺
   - 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。

   避免死锁最简单的方法是阻止循环等待条件，将系统中所有资源设置标志位、排序、规定所有进程申请资源必须以一定的顺序做操作来避免死锁。

10. java多线程中调用wait()和sleep()方法有什么不同？

    java程序中wait和sleep都会造成某种形式的暂停，它们可以满足不同的需求。wait()方法用于线程间通信，如果等待条件为真且其它线程被唤醒时它会释放锁，而sleep()方法仅仅释放CPU资源或者让当前线程停止执行一段时间，但不会释放锁。

## 数据库

1. 主键、外键、超键、候选键
   - 主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值null。
   - 外键：在一个表中存在的另一个表的主键称此表的外键。
   - 超键：在关系中能唯一标识元祖的属性集称为关系模式的超键。一个属性可以作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。
- 候选键：是最小超键，即没有冗余元素的超键。
   
2. 什么是存储过程？用什么来调用？

   存储过程是一个预编译的sql语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次sql，使用存储过程比单纯sql语句执行要快。

   调用：

   - 可以用一个命令对象来调用存储过程。
   - 可以供外部程序调用，比如java程序。

3. 存储过程的优缺点

   优点：

   - 存储过程是预编译过的，执行效率高。
   - 存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。
   - 安全性高，执行存储过程需要有一定权限的用户。
   - 存储过程可以重复使用，可减少数据库开发人员的工作量。

   缺点：

   - 移植性差。

4. 什么是临时表，临时表什么时候删除？

   - 临时表可以手动删除。
   - 临时表只在当前连接可见，当关闭连接时，mysql会自动删除表并释放所有空间。因此在不同的连接中可以创建同名的临时表，并且操作属于本连接的临时表。
   - 创建临时表的语法与创建表语法类似，不同之处是增加关键字`TEMPORARY`。

5. 非关系型数据库和关系型数据库区别，优势比较？

   `非关系型数据库的优势`(HBase、Redis、MongoDB、Couchbase、LevelDB)：

   - 性能：NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。
   - 可扩展性：同样也是因为基于键值对，数据之间没有耦合性，所以非常容易扩展。

   `关系型数据库的优势`（mysql、SQL Sever、Oracle、Sybase、DB2、PostgreSQL）：

   - 复杂查询：可以用SQL语句方便的在一个表与多个表之间做非常复杂的数据查询。
   - 事物支持：使得对于安全性能很高的数据访问要求得以实现。

   `其他`：

   - 对于这两类数据库，对方的优势就是自己的弱势，反之亦然。
   - NOSQL数据库慢慢开始具备SQL数据库的一些复杂查询功能，比如MongoDB。
   - 对于事务的支持也可以用一些系统级的原子操作来实现，例如乐观锁之类的方法来曲线救国，比如Redis set nx。

6. 数据库范式
   - 第一范式：（确保每列保存原子性）所有字段值都是不可分解的原子值。
   - 第二范式：（确保表中的每列都和主键相关）在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。
   - 第三范式：（确保每列都和主键列直接相关，而不是间接相关）数据表中的每一列数据都和主键直接相关，而不能间接相关。第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。

7. 什么是索引

   数据库索引，是数据库管理系统中一个排序的数据结构，索引的实现通常使用B树及其B+树。

   在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。

8. 索引的作用？它的优缺点？

   `索引的作用`：

   协助快速查询、更新数据库表中的数据。

   为表设置索引要付出代价的：

   - 增加了数据库的存储空间
   - 在插入和修改数据时要花费较多的时间（因为索引也要随之变动）

   `索引的优点`：

   - 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
   - 可以大大加快数据的检索速度，这也是创建索引的最主要原因。
   - 可以加速表和表之间连接，特别是在实现数据的参考完整性方面特别有意义。
   - 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。
   - 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统性能。

    `索引的缺点`：

   - 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。
   - 索引需要占物理空间，除了数据表占数据空间外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。
   - 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。

9. 什么是`事务`

   事务是对数据库中一系列操作进行统一回滚或者提交的操作，主要用来保证数据的完整性和一致性。

10. 事务四大特性(ACID)原子性、一致性、隔离性、持久性

    `原子性`

    原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。

    `一致性`

    事务开始前和结束后，数据库的完整性约束没有被破坏。比如A向B转账，不可能A扣了钱，B却没有收到。

    `隔离性`

    隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启一个事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。

    `持久性`

    持久性是指一事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失对提交事务的操作。

11. 事务的并发？事务隔离级别，每个级别会引发什么问题，mysql默认是哪个级别？

    从理论上来说，事务应该彼此完全隔离，以避免并发事务所导致的问题，然而，那样会对性能产生极大的影响，因为事务必须按顺序运行，在实际开发中，为了提升性能，事务会以较低的隔离级别运行，事务的隔离级别可以通过隔离事务属性指定。

    `事务的并发问题`

    - 脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据。

    - 不可重复读：事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。

    - 幻读：幻读解决了不重复读，保证了同一个事务里，查询的结果都是事务开始时的状态（一致性）。

      例如：事务T1对一个表中所有的行的某个数据项做了从“1”修改“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给了数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有跟没有修改一样，其实这行就是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。

    `小结`

    不可重复读和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或者删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。

    `事务的隔离级别`

    - 读未提交：另一个事务修改了数据，但尚未提交，而本事务中的SELECT会读到这些未被提交的数据脏读。
    - 不可重复读：事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。
    - 可重复读：在同一事务里，SELECT的结果是事务开始时时间点的状态，因此，同样的SELECT操作读到结果会是一致的。
    - 串行化：最高的隔离级别，在这个隔离级别下，不会产生任何异常，并发的事务，就像事务是在一个个按照顺序执行一样。

    

    

    