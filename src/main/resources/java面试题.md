- String s1= "abc"

- String s2 = new String("abc")

  关于s1与s2的底层分析，[详见](https://www.jianshu.com/p/72b45340af72)

1. 四种引用

   - `强引用`

     任何通过强引用所使用的对象不管系统资源有多紧张，java GC都不会主动回收具有强引用的对象。

   - `弱引用`

     如果一个对象只具有弱引用，无论内存充足与否，java gc后对象如果只有弱引用将会被自动回收。

   - `软引用`

     软引用在内存不足时才被回收，如果一个对象只具有软引用，java gc在内存充足的时候不会回收它，内存不足时才会被回收。

   - `虚引用`

     java gc会把虚引用的对象放到引用队列里面，可用来在对象被回收时做额外的一些资源清理或事物回滚等处理，跟踪垃圾回收器

2. JDK与JRE

   - JDK

     java development kit 的简称，java开发工具包，提供了java的开发环境和运行环境。

   - JRE

     java runtime environment的简称，java运行环境，为java提供了所需环境。

   - `总结`
     具体来说，JDK包含了JRE，同时还包含了编译java源码的编译器javac，还包含了很多java程序调试和分析工具，简单来说：如果你需要运行java程序，只需安装JRE就可以了，如果你需要编写java程序，需要安装JDK。

3. 两个对象的hashCode()相同，则equals()也一定为true？

   不对，两个对象的hashCode()相同，equals()不一定true。

   通话与重地，这两个对象的hashCode()是相同的，但equals()不同。

4. String、StringBuffer、StringBuilder

   String声明的是`不可变对象`，每次操作都会生成`新的对象`，然后将指针指向新的String对象，而StringBuffer、StringBuilder可以在原有的对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用String。

   StringBuffer和StringBuilder最大的区别在于，StringBuffer是线程安全的，而StringBuilder是非线程安全的，但StringBuilder的性能却高于StringBuffer，所以在单线程环境下推荐使用StringBuilder，多线程环境下推荐使用StringBuffer。

5. `BIO`、`NIO`、`AIO`
   
   - `BIO`：Block IO同步阻塞式IO,就是我们平常使用的传统IO，它的特点是模式简单使用方便，并发处理能力低。
   - `NIO`：New IO 同步非阻塞IO,是传统IO的升级，客户端和服务器端通过Channel通讯，实现了多路复用。
- `AIO`：Asynchronous IO是NIO的升级，也叫NIO2，实现了异步非阻塞IO，异步IO的操作基于事件与回调机制。
  
6. Collection和Collections有什么区别？

   - java.util.Collection是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在java类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承的接口有List和Set。
   - Collections是集合类的工具类，用于对集合中元素进行排序、搜索以及线程安全等各种操作。

7. HashMap和HashTable的区别

   - hashMap去掉了hashTable的contains的方法，但是加上了containsValue()和containsKey()方法。
   - hashTable同步的，而hashMap是非同步的，效率上比hashTable要高。
   - hashMap允许空键值，而hashTable不允许.

8. ArraysList和LinkedList的区别

   最明显的区别是ArraysList底层的数据结构是数组，支持随机访问，而LinkedList的底层数据结构是双向链表，不支持随机访问，使用下标访问一个元素，ArrayList的时间复杂度是O(1)，而LinkedList是O(n)。

9. ArrayList和Vector的区别

   - Vector是同步的，而ArrayList不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。
   - ArrayList比Vector快，它因为有同步，不会过载。
   - ArrayList更加通用，因为我们可以使用Collections工具类获取同步列表和只读列表。

10. 哪些集合类是线程安全的

    - vector：比arraysList多了个同步机制（线程安全），因为效率低，现在已经不太建议使用。
    - statck：堆栈类，先进后出。
    - hashTable：比hashmap多了个线程安全。
    - enumeration：枚举，相当于迭代器。

11. 为什么重写equals时必须重写hashCode方法？

    - hashCode：hashCode()的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希码表中的索引位置。hashCode()定义在JDK的Object.java中，这意味着java中的任何类都包含有hashCode()函数。
    - equals它的作用也是判断两个对象是否相等，如果对象重写了equals()方法，比较两个对象的内容是否相等；如果没有重写，比较两个对象的地址是否相同，等价于"=="。equals()定义在JDK的Object.java中，这意味着java中任何类都包含有equals()函数。
    - 对于两个相同的对象，如果重写了equals()方法，则认为它们的内容相等，如果没有重写hashCode()方法，则放入set中会有重复元素。

12. `序列化`与`反序列化`

    - 序列化：把java对象转换为字节序列。
    - 反序列化：把字节序列恢复为java对象的过程。

    - 对象序列化主要有两种用途：
      - 把对象的字节序列永久的保存在硬盘上，通常存放在一个文件中。（持久化对象）
      - 在网络上传送对象的字节序列（网络传输对象）



## 集合

1. 常用的集合类有哪些？

   Map接口和Collection接口是所有集合框架的父接口：

   - Collection接口的子接口包括：Set接口和List接口
   - Map接口的实现类主要有：HashMap、TreeMap、HashTable、ConcurrentHashMap以及Properties等
   - Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等
   - List接口的实现类主要有：ArraysList、LinkedList、Stack以及Vector等

2. Collection

   1. List
      - Arraylist：Object数组，初始化容量大小为10
      - Vector：Object数组，初始化容量大小为10
      - LinkedList：双向循环链表
   2. Set
      - HashSet(无序，唯一)：基于HashMap实现的，底层采用HashMap来保存元素
      - LinkedHashSet：LinkedHashSet继承于HashSet，并且其内部是通过LinkedhashMap来实现的。
      - TreeSet(有序，唯一)：红黑树

3. Map

   - HashMap：JDK1.8之前HashMap由数组+链表组成，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突），JDK1.8以后再解决哈希冲突时，当链表长度大于8时，将链表转化为红黑树，以减少搜索时间
   - LinkedHashMap：LinkedHashMap继承自HashMap，所以它的底层仍然是基于拉链式散列结构，即有数组和链表或者红黑树组成。另外，LinkedHashMap在上面结构的基础上，增加了一条双向链表，使得上面的结果可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。
   - HashTable：数组+链表组成。继承Dictionary抽象类，实现Map接口，初始化容量大小为11
   - TreeMap：红黑树

4. 哪些集合类是线程安全的？

   - Vector：比ArrayList多了个synchronized(线程安全),因为效率较低，现在已经不太建议使用。
   - hashTable：就比hashMap多了个synchronized(线程安全)，不建议使用
   - `ConcurrentHashMap`：是java5中支持高并发、高吞吐量的线程安全HashMap实现。它由Segment数组和HashEntry数组结构组成。Segment数组在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键-值对数据。一个ConcurrentHashMap里面包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表的结构；一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素；每个Segment守护一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改的时候，必须首先获得它对应的Segment锁。

5. ArrayList和Vector的区别是什么？

   这两个类都实现了List接口（List接口继承了Collection接口），它们都是有序集合

   - 线程安全：Vector使用了Synchronized来实现线程同步，是线程安全的，而ArrayList是非线程安全的。
   - 性能：ArrayList在性能方面要优于Vector
   - 扩容：ArrayList和Vector都会根据实际的需要动态的调整容量，只不过在Vector扩容每次会增加一倍，而ArrayList只会增加50%。

6. 插入数据时，ArrayList、LinkedList、Vector谁速度较快？

   - ArrayList和Vector底层的实现都是使用数组方式来存储数据。数据元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢。
   - Vector中的方法由于加了synchronized修饰，因此Vector是线程安全容器，但是性能上较ArrayList差。
   - LinkedList使用的是双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但插入数据时只需要记录当前项的前后项即可，所以LinkedList插入速度快。

7. List和Set的区别

   - List、Set都是继承自Collection接口
   - List特点：一个有序（元素存入集合的顺序和取出顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常见的实现类有ArrayList、LinkedList、Vector。
   - Set特点：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set接口常用实现类是HashSet、LinkedHashSet已经TreeSet。
   - 另外List支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。

   Set和List的对比

   - Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。
   - List：和数组类似，List可以动态增长，查找元素效率高，插入元素效率低，因为会引起其他元素位置改变。

8. HashSet的实现原理

   HashSet是基于HashMap实现的，HashSet的值存放于HashMap的key上，HashMap的value统一为parent，因此HashSet的实现比较简单，相关HashSet的操作，基本上都是直接调用底层HashMap相关方法来完成，HashSet不允许重复值。

9. hashCode()与equals()的相关规定：
   - 如果两个对象相等，则hashcode一定相同（hashcode是jdk根据对象的地址或者字符串或者数字算出来的int类型的数值）
   - 两个对象相等，对两个equals方法返回true
   - 两个对象有相同的hashcode值，则它们也不一定相等（通话与重地）
   - equals方法被重写，则hashcode方法也必须被重写
   - hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）
   
10. == 与equals的区别，[详见](https://zhuanlan.zhihu.com/p/121603364)
    
    - 对于==，比较的是指是否相等
      - 如果作用于基本数据类型的变量，则直接比较其存储的值是否相等
      - 如果作用于引用类型的变量，则比较的是所指向的对象的地址是否相等
    - 对于equals方法，比较的是是否是同一个对象
      - 首先，equals不能作用于基本数据类型的变量
      - equals()方法存在于Object类中，如果没有重写equals()方法，调用equals()方法的效果其实和使用==效果一样，也是比较的是引用类型的变量所指向的对象地址，若重写了equals()方法，则比较的就是两个对象的值。
    
11. 说一下HashMap的实现原理？

    - HashMap概述：HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。
    - HashMap的数据结构：在java编程语言，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。
    - HashMap基于Hash算法实现的
      - 当我们往HashMap中put元素时，利用key的hashCode重新hash计算出当前对象元素在数组中的下标
      - 存储时，如果出现hash值相同的key，此时有两种情况：
        - 如果key相同，则覆盖原始值
        - 如果key不同（出现冲突），则将当前的key-value放入链表中
      - 获取时，直接找到hash值对应的下标，进一步判断key是否相同，从而找到对应值
      - 理解了以上过程就不难明白HashMap是如何解决hash冲突的问题，核心就是使用了数组的存储方式，然后将冲突的key的对象放入链表中，一旦发现冲突就在链表中做进一步的对比。
    - 在JDK1.8中对HashMap的实现做了优化，当链表中的节点数据超过八个之后，该链表会转为红黑树来提高查询效率，从原来的O(n)到O(logn)

12. HashMap的底层实现？HashMap在JDK1.7和JDK1.8中有哪些不同？

    - 数组的特点：寻找容易，插入和删除困难
    - 链表的特点：寻址容易，但插入和删除容易

    故我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做拉链法的方式可以解决哈希冲突。

    - JDK1.8之前
      - 采用的是`拉链法`(将链表和数组相结合)。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。
    - JDK1.8之后
      - JDK1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8时），将链表转化为红黑树，以减少搜索时间。
    
13. JDK1.7 VS JDK1.8

    JDK1.8主要解决或者优化了以下问题：

    - resize扩容优化
    - 引入了红黑树，目的是避免单条链表过长而影响查询效率
    - 解决了多线程死循环问题，但仍是非线程安全的，多线程时可能会造成数据丢失问题。

14. HashMap的扩容操作是怎么实现的？

    - 在jdk1.8中，resize方法是在hashmap中的键值对大于阈值时或者初始化时，就调用resize方法进行扩容。
    - 每次扩展的时候，都扩展2倍。
    - 扩展后Node对象的位置要么在原位置，要么移动到原偏移量两倍的位置。
    - 在putVal()中，我们看到在这个函数里面使用到了2次resize()方法，resize()方法表示的在进行第一次初始化时会对其进行扩容，或者当该数组的实际大小大于其临界值（第一次为12），这个时候在扩容的同时也会伴随桶上面的元素进行重新分发，这也是JDK1.8版本的一个优化地方，在1.7中，扩容之后需要重新去计算其hash值，根据hash值对其进行分发，但在1.8版本中，则是根据在同一桶的位置中进行判断（e.hash & oldCap）是否为0，重新进行hash分配后，该元素的位置要么停留在原来的位置，要么移动到原始位置+原数组大小

15. 什么是哈希

    hash,一般翻译为“`散列`”，也有直接音译为“哈希”的，hash就是指使用哈希算法把任意长度的二进制映射为固定长度的较小的二进制值，这个较小的二进制值叫做哈希值。

16. 什么是`哈希冲突`

    当两个不同的输入值，根据同一散列函数计算出相同的散列值的现场，我们就把它叫做哈希碰撞

17. HashMap的数据结构
    - 在java中，保存数据有两种比较简单的数据结构，数组和链表。
      - 数组的特点：寻址容易，插入和删除困难
      - 链表的特点：寻址困难，插入和删除容易
    - 所以我们将数组和链表结合在一起，发挥两者各自的优势，就可以使用两种方式：链地址法和开发地址法可以解决哈希冲突。
    - 链表法就是将相同hash值的对象组织成一个链表放在hash值对应的槽位
    - 开发地址法是通过一个探测算法，当某个槽位已经被占据的情况下继续查找下一个可以使用的槽位

18. hash()函数

    如果使用hashCode取余，那么相当于参与运算的只有hashCode的低位，高位是没有起到任何作用的，所以我们的思路就是让hashCode取值出的高位也参与运算，进一步降低hash碰撞的概率，使得数据分布更平均，我们称之为扰动。

    ```java
    static final int hash(Object key){
        int h;
        //与自己右移16位进行异或运算（高低位异或）
        return (key == null)? 0:(h = key.hashCode()) ^ (h >>> 16);
    }
    ```

19. 能否使用任何类作为Map的key?

    可以使用任何类作为Map的key，然而在使用之前，需要考虑以下几点：

    - 如果类重写了equals()方法，也应该重写hashCode()方法。
    - 类的所有实例需要遵循与equals()和hashCode()相关的规则。

20. 如果使用Object作为HashMap的key，应该怎么办？

    重写`hashCode()`和`equals()`方法

    - 重写`hashCode()`是因为需要计算存储数据的存储位置，需要注意不要试图从散列码计算中排除一个对象的关键部分来提高性能，这样虽然能更快但是可能会导致更多的hash碰撞；
    - 重写`equals()`方法，需要遵守自反性、对称性、传递性、一致性以及对于任何非Null的引用值x，x.equals(null)必须返回false的这几个特性，目的是为了保证key在哈希表中的唯一性。

21. HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？

    `hashCode()`方法返回的是int整数类型，其范围是-(2^31)~(2^31 -1)，而hashMap的容量范围是在16（默认值）~2^30，hashmap通常情况下是取不到最大值的，并且设备上也难以提供这么多的存储空间，从而导致通过`hashCode()`计算出的哈希值可能不在数组大小范围内，进而无法匹配存储位置。

    - 解决方案：
      - HashMap自己实现了自己的`hash()`方法，通过2次扰动使得它自己的哈希值高低位自行进行异或运算，降低哈希碰撞概率也使得数据分布更平均
      - 在保证数组长度为2的幂次方的时候，使用`hash()`运算之后的值与运算(&)（数组长度-1）来获取数组下标的方式进行存储，这样一来是比取余操作更有效率，二来也是因为只有当数组长度为2的幂次方时，h&(length -1)才等价于h %length，三来解决了“哈希值与数组方法大小范围不匹配”的问题。

22. HashMap的长度为什么是2的幂次方

    - 为了能让hashMap存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀，每个链表/红黑树长度大致相同

    - 算法如何设计

      - hash % length == hash &(length -1)的前提是length是2的n次方
      - 采用二进制位操作&，相对于%能够提高运算效率。

    - 为什么是两次扰动

      这样就是加大哈希值低位随机性，使得分布更均匀，从而提高数组存储下标位置的随机性和均匀性，最终减少hash冲突，两次就够了，已经达到了高位低位同时参与运算的目的。

23. HashMap与HashTable有什么区别

    - 线程安全：HashMap是非线程安全的，HashTable是线程安全的，HashTable内部的方法基本都经过`synchronized`修饰
    - 效率：hashMap高很多
    - 对Null key 和Null value的支持：HashMap中，Null可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为Null。但是在HashTable中put进的键值只要有一个null，直接抛异常。
    - 初始容量大小和每次扩充容量大小的不同：
      - 创建时，初始化容量，HashTable的默认初始化大小为11，之后每次扩充，容量变为原来的2n+1。HashMap默认的初始化大小为16，之后每次扩充，容量变为原来的2倍。
      - 创建时如果给定容量初始值，HashTable会直接使用你给定的大小，而HashMap会将其扩充为2的幂次方大小。

24. 什么是TreeMap

    - TreeMap是一个有序的key-value集合，它是通过红黑树实现的
    - TreeMap基于红黑树实现，该映射根据其键的自然顺序进行排序，或者创建映射时提供的Comparator进行排序。
    - TreeMap是线程非同步的

25. 如何决定使用HashMap还是TreeMap？

    对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的Key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序Key的遍历。

26. HashMap和ConcurrentHashMap的区别

    - ConcurrentHashMap对整个桶数组进行了分割片段（Segment），然后在每一个分段上都用lock锁进行保护，相对于HashTable的synchronized锁的粒度更精细了一些，并发性能更好，而HashMap没有锁进制，不是线程安全的（JDK1.8之后ConcurrentHashMap启用了一种全新的方式是实现，利用CAS算法）
    - HashMap的键值对允许有Null，但是ConcurrentHashMap不允许。

27. [ConcurrentHashMap](https://www.jianshu.com/p/2554b0cd169b)和HashTable的区别

    - ConcurrentHashMap和HashTable的区别主要体现在实现线程安全的方式上不同。
      - 底层数据结构：JDK1.7的ConcurrentHashMap底层采用`分段的数组`+`链表`实现，JDK1.8采用的数据结构跟HashMap1.8的结构一样，`数组+链表+红黑树`。HashTable和JDK1.8之前的HashMap的底层数据结构采用数组+链表，数组和HashMap的主体，链表则是主要为了解决哈希冲突而存在的。

    - 实现线程安全的方式：
      - 在`JDK1.7`的时候，ConcurrentHashMap(分段锁)对整个桶数组进行了分割片段（Segment），每一把锁只锁容器其中一部分数据，多线程访问容器里面不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配16个Segment，比HashTable效率提高16倍），到了`JDK1.8`的时候已经摒弃了`Segment`的概念，而是直接用`Node数组+链表+红黑树`的数据结构来实现，并发控制使用synchronized和CAS来操作，整体看起来就像是优化过且线程安全的HashMap。
      - HashTable（`同一把锁`）：使用synchronized来保证线程安全，效率非常低。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用put添加元素，另一个线程不能使用put添加元素，也不能使用get，竞争会越来越激烈效率越低。

## JVM

1. jvm`内存模型`及其作用
   - 程序计数器：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令。
   - java虚拟机栈：用于存储局部变量表、操作数栈、动态链接、方法出口等信息。
   - 本地方法栈：与虚拟机栈的作用一样，只不过虚拟机栈是服务java方法的，而本地方法栈是为虚拟机调用Native方法服务的。
   - java堆：java虚拟机中内存最大的一块，是所有线程共享的，几乎所有的对象实例都在这里分配内存。
   - 方法区：用于存储已被虚拟机加载的类信息、常量、静态变量、即使编译后的代码等数据。
2. `深拷贝`和`浅拷贝`
   
   - 浅拷贝：只是增加了一个指针指向已存在的内存地址。
   - 深拷贝：增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存；使用深拷贝的情况下，释放内存的时候不会因为出现浅拷贝时释放同一个内存的错误。类比于`原型模式`
   - 浅复制：仅仅是指向被复制的内存地址，如果原地址发生改变，那么浅复制出来的对象也会相应的改变。
- 深复制：在计算机中开辟一块新的内存地址用于存放复制的对象。
  
3. java的内存泄漏

   内存泄漏是指不再被使用的对象或者变量一直被占据在内存中。理论上来说，java是有GC垃圾回收机制的，也就是说，不再被使用的对象，会被GC自动回收掉，自动从内存中清除。但是，即使这样，java也会存在着内存泄漏的情况，java导致内存泄漏的原因很明确：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄漏的发生场景。

4. java中的引用类型

   - 强引用：发生gc的时候不会被回收。
   - 弱引用：有用但不是必须对象，在下次GC时被回收。
   - 软引用：有用但不是必须对象，在发生内存溢出之前被回收。
   - 虚引用：无法通过虚引用获得对象，用PathtomReference实现虚引用，虚引用的作用是在gc时返回一个通知。

5. 怎么判断对象是否可以被回收？

   垃圾收集器在做垃圾回收的时候，首先需要判定的就是那些内存是需要被回收的，哪些对象是存活的，哪些对象是死掉的。

   `引用计数法`：为每个对象创建一个引用计数，有对象引用时计数器+1，引用被释放时计数-1，当计数器为0时就可以被回收。它有一个`缺点`不能解决循环引用的问题。

   `可达性分析算法`：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是可以被回收的。

6. GC Roots

   - java虚拟机栈中对象的引用
   - 方法区中类静态变量的引用
   - 方法区中常量的引用
   - 本地方法栈中的JNI引用的对象

7. JVM中的垃圾回收算法

   - 标记-清除算法：标记无用对象，然后进行清除回收。

     缺点：效率不高，会产生垃圾碎片

   - 复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。

     缺点：内存使用率不高，只有原来的一半。

   - 标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。
   - 分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。

8. JVM中的垃圾回收器

9. 简述分代垃圾回收器是怎么工作的？

   分代回收器有两个分区：新生代和老年代，占比1：2。

   新生代使用的是复制算法，新生代有3个分区：Eden、From Survivor、To Survivor，它们默认占比8:1:1，它们的执行流程如下：

   - 将Eden + From Survivor存活的对象放入To Survivor区；
   - 清空Eden和From Survivor分区；
   - Eden + To Survivor存活对象放入 From Survivor。

   每次在From Survivor到To Survivior移动时都存活的对象，年龄+1，当年龄达到15（默认是15）时，升级为老年代。大对象直接进入老年代。

   老年代当空间占用到达某个值之后就会触发全局垃圾回收，一般使用标记整理的执行算法。

10. 内存分配策略

    对象的内存分配通常是在java堆上分配（随着虚拟机优化技术的诞生，某些场景下也会栈上分配），对象主要分配在新生代的Eden区，如果启动了本地线程缓冲，将按照线程优先在TLAB上分配。少数情况下也会直接在老年代上分配。总的来说分配规则不是百分百固定的，其细节取决于哪一种垃圾收集器组合以及虚拟机相关参数有关。

    - 对象优先在Eden区分配

      多数情况下，对象都在新生代Eden区分配，当Eden区分配没有足够的空间进行分配时，虚拟机将会发起一次Minor GC；如果本次GC后还是没有足够的空间，则将启用分配担保机制在老年代中分配内存。

    - 大对象直接进入老年代
    - 长期存活对象将进入老年代





## 类加载机制

1. 简述类加载机制

   虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验，解析和初始化，最终形成可以被虚拟机直接使用的java类型。

2. JVM加载class文件的原理机制

   java中的所有类，都需要由类加载器装载到JVM中才能运行。类加载器本身也是一个类，而它的工作就是把class文件从硬盘读取到内存中。

   - 隐式装载：程序在运行过程中当碰到通过new等方式生成对象时，隐式调用类装载器加载对应的类到jvm中。
   - 显式装载：通过class.forname()等方法，显式加载需要的类。

   java类的加载是动态的，它并不会一次性将所有类全部加载后运行，而是保证程序运行的基础类完全加载到jvm中，至于其他类，则在需要的时候才加载。

3. 类装载执行过程

   类装载分为以下5个步骤：

   - 加载：根据查找路径找到相应的class文件然后导入；
   - 验证：检查加载的class文件的正确性；
   - 准备：给类中的静态变量分配内存空间；
   - 解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用可以理解为一个标识，而在直接引用中直接指向内存中的地址；
   - 初始化：对静态变量和静态代码块执行初始化工作。

4. 双亲委派模型

   如果一个类加载器收到了类加载请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试去加载类。

   当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加载。

5. JVM调优工具

   JDK自带很多监控工具，都位于JDK的bin目录下，其中最常用的是jconsole和jvisualvm这两款视图监控工具。

   - jconsole：用于对JVM中的内存、线程和类等进行监控。
   
   - jvisualvm：JDK自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc变化等。
   
     

## 多线程

1. 什么是线程和进程

   - 进程：在操作系统中能够独立运行，并且作为资源分配的基本单位。它表示运行中的程序。系统运行一个程序就是一个进程从创建、运行到消亡的过程。
   - 线程：是一个比进程更小的执行单位，能够完成进程中的一个功能，也被称为轻量级进程。一个进程在其执行的过程中可以产生多个线程。

   - 线程与进程不同的是：同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序技术器、虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小的多。

2. 什么是线程

   线程是操作系统能够进行运算调度的最小单位，它被包含在进程中，是进程中的实际运作单位。

3. 进程和线程的区别

   线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同任务。不同进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。别把它和栈内存搞混，每个线程都拥有单独的栈内存用来存储本地数据。

4. Thread类中的start()和run()方法有什么区别

   start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。

5. 什么是线程安全

   如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。一个线程安全的计数器类的同一实例对象在被多个线程使用的情况下也不会出现计算失误。

6. 什么是`ThreadLocal`变量

   ThreadLocal使用场合主要解决多线程中数据数据因并发产生不一致问题。`ThreadLocal`为每个线程中并发访问的数据提供一个副本，通过访问副本来运行业务，这样的结果是耗费内存，但大大减少了线程同步所带来的性能消耗，也减少了线程并发控制的复杂度。

   ThreadLocal不能使用原子类型，只能使用Object类型，ThreadLocal的使用比synchronized要简单的多。

   ThreadLocal和synchonized都用于解决多线程并发访问。但是ThreadLocal与synchonized有本质区别，synchonized是利用锁的机制，是变量或代码块在某一时刻只能被一个线程访问。而ThreadLocal为每一个线程都提供了变量副本，使得每个线程在某一时间访问到的并不是同一个对象，这样就隔离了多个线程对数据的共享，而synchronized却正好相反，它用于在多个线程间通信时能够获得数据共享。

7. java中堆和栈有什么不同

   每个线程都有自己的栈内存，用于存储本地变量，方法参数和栈调用，一个线程中存储的变量对其它线程是不可见的。而堆是所有线程共享的一片公用内存区域。对象都在堆里创建，为了提升效率线程会从堆中弄一个缓存到自己的栈中，如果多线程使用该变量就可能会引发问题，这时`volatile`变量就可以发挥作用了，它要求线程从主存中读取变量的值。

8. 什么是线程池？为什么使用它？

   创建线程要花费昂贵的资源和时间，如果任务来了才创建那么相应时间会变长，而且一个进程能创建的线程数有限。为了避免这些问题，在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程。

9. 如何避免死锁

   死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。这是一个严重的问题，因为死锁会让你的程序挂起无法完成任务。

   死锁发生必须满足的四个条件：

   - 互斥条件：一个资源每次只能被一个进程使用
   - 请求与保持：一个进程因请求资源而阻塞时，对已获得的资源保持不放
   - 不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺
   - 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。

   避免死锁最简单的方法是阻止循环等待条件，将系统中所有资源设置标志位、排序、规定所有进程申请资源必须以一定的顺序做操作来避免死锁。

10. java多线程中调用wait()和sleep()方法有什么不同？

    java程序中wait和sleep都会造成某种形式的暂停，它们可以满足不同的需求。wait()方法用于线程间通信，如果等待条件为真且其它线程被唤醒时它会释放锁，而sleep()方法仅仅释放CPU资源或者让当前线程停止执行一段时间，但不会释放锁。

11. 什么是CAS

    CAS,compare and swap的缩写，即比较并交换。

    CAS操作包含三个操作数---内存位置(v)、预期原值(A)和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。无论哪种情况，它都会在CAS指令之前返回该位置的值。（在CAS的一些特殊情况下将仅返回CAS是否成功，而不提取当前值。）CAS有效说明了“我认为位置V应该包含值A；如果包含该值，则将B放到这个位置；否则，不要更改该位置，只告诉我这个位置现在值即可”。

    通常将CAS用于同步的方式是从地址V读取值A，执行多步计算来获取新值B，然后使用CAS将V值从A改为B。如果V处的值尚未同时更改，则CAS操作成功。

    类似于CAS的指令允许算法执行读-修改-写操作，而无需害怕其他线程同时修改变量，因为如果其他线程修改变量，那么CAS会检测它并失败，算法可以对该操作重新计算。

12. CAS存在的问题

    CAS虽然很高效的解决了原子操作，但是CAS仍然存在三大问题。ABA问题，循环时间长开销大和只能保证一个共享变量的原子操作。

    1. ABA问题。因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加版本号，每次变量更新的时候把版本号加一，那么A-B-A就会变为1A-2B-3A。

       在atomic包下提供了一个类解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。

    2. 循环时间长开销大

       自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延长流水线执行指令，使CPU不会消耗过多的执行资源，延迟时间取决于具体实现的版本，在一些处理器上延迟时间是0。第二它可以避免在退出循环的时候因内存顺序冲突(memory order violation)而引起CPU流水线被清空(CPU pipeline flush)，从而提高CPUde 执行效率。

    3. 只能保证一个共享变量的原子操作

       当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如 有两个共享变量i = 2,j = a，合并一下ij=2a，然后用CAS来操作ij。从java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。

13. AQS 

    AbstractQueuedSynchronizer，即队列同步器。它是构建锁或者其他同步组件的基础框架（ReentrantLock、ReentrantReadWriteLock、Semaphore等）。

    AQS解决了子类实现同步器时涉及到的大量细节问题，例如获取同步状态、FIFO同步队列。基于AQS来构建同步器可以带来很多好处。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了，所以使用AQS不仅能够极大地减少实现工作，而且也不必处理在多个位置上发生的竞争问题。

    在基于AQS构建的同步器中，只能在一个时刻发生阻塞，从而降低上下文切换的开销，提高了吞吐量。同时在设计AQS时充分考虑了可伸缩行，因此J.U.C中所有基于AQS构建的同步器均可以获取这个优势。

    AQS的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态。

    AQS使用一个int类型的成员变量state来表示同步状态，当state>0时表示已经获取了锁，当state=0时表示释放了锁。它提供了三个方法来对同步状态state进行操作，当然AQS可以确保对state的操作时安全的。

    AQS通过内置的FIFO同步队列来完成资源获取线程的派对工作，如果当前线程获取同步状态失败（锁）时，AQS则会将当前线程以及等待状态等信息构造成一个节点(Node)并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，则会把节点中的线程唤醒，使其再次尝试获取同步状态。

## 数据库

1. 主键、外键、超键、候选键
   - 主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值null。
   - 外键：在一个表中存在的另一个表的主键称此表的外键。
   - 超键：在关系中能唯一标识元祖的属性集称为关系模式的超键。一个属性可以作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。
   
   - 候选键：是最小超键，即没有冗余元素的超键。
   
- 候选键：是最小超键，即没有冗余元素的超键。
  
2. 什么是存储过程？用什么来调用？

   存储过程是一个预编译的sql语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次sql，使用存储过程比单纯sql语句执行要快。

   调用：

   - 可以用一个命令对象来调用存储过程。
   - 可以供外部程序调用，比如java程序。

3. 存储过程的优缺点

   优点：

   - 存储过程是预编译过的，执行效率高。
   - 存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。
   - 安全性高，执行存储过程需要有一定权限的用户。
   - 存储过程可以重复使用，可减少数据库开发人员的工作量。

   缺点：

   - 移植性差。

4. 什么是临时表，临时表什么时候删除？

   - 临时表可以手动删除。
   - 临时表只在当前连接可见，当关闭连接时，mysql会自动删除表并释放所有空间。因此在不同的连接中可以创建同名的临时表，并且操作属于本连接的临时表。
   - 创建临时表的语法与创建表语法类似，不同之处是增加关键字`TEMPORARY`。

5. 非关系型数据库和关系型数据库区别，优势比较？

   `非关系型数据库的优势`(HBase、Redis、MongoDB、Couchbase、LevelDB)：

   - 性能：NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。
   - 可扩展性：同样也是因为基于键值对，数据之间没有耦合性，所以非常容易扩展。

   `关系型数据库的优势`（mysql、SQL Sever、Oracle、Sybase、DB2、PostgreSQL）：

   - 复杂查询：可以用SQL语句方便的在一个表与多个表之间做非常复杂的数据查询。
   - 事物支持：使得对于安全性能很高的数据访问要求得以实现。

   `其他`：

   - 对于这两类数据库，对方的优势就是自己的弱势，反之亦然。
   - NOSQL数据库慢慢开始具备SQL数据库的一些复杂查询功能，比如MongoDB。
   - 对于事务的支持也可以用一些系统级的原子操作来实现，例如乐观锁之类的方法来曲线救国，比如Redis set nx。

6. 数据库范式
   - 第一范式：（确保每列保存原子性）所有字段值都是不可分解的原子值。
   - 第二范式：（确保表中的每列都和主键相关）在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。
   - 第三范式：（确保每列都和主键列直接相关，而不是间接相关）数据表中的每一列数据都和主键直接相关，而不能间接相关。第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。

7. 什么是索引

   数据库索引，是数据库管理系统中一个排序的数据结构，索引的实现通常使用B树及其B+树。

   在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。

8. 索引的作用？它的优缺点？

   `索引的作用`：

   协助快速查询、更新数据库表中的数据。

   为表设置索引要付出代价的：

   - 增加了数据库的存储空间
   - 在插入和修改数据时要花费较多的时间（因为索引也要随之变动）

   `索引的优点`：

   - 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
   - 可以大大加快数据的检索速度，这也是创建索引的最主要原因。
   - 可以加速表和表之间连接，特别是在实现数据的参考完整性方面特别有意义。
   - 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。
   - 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统性能。

    `索引的缺点`：

   - 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。
   - 索引需要占物理空间，除了数据表占数据空间外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。
   - 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。

9. 什么是`事务`

   事务是对数据库中一系列操作进行统一回滚或者提交的操作，主要用来保证数据的完整性和一致性。

10. 事务四大特性(ACID)原子性、一致性、隔离性、持久性

    `原子性`

    原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。

    `一致性`

    事务开始前和结束后，数据库的完整性约束没有被破坏。比如A向B转账，不可能A扣了钱，B却没有收到。

    `隔离性`

    隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启一个事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。

    `持久性`

    持久性是指一事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失对提交事务的操作。

11. 事务的并发？事务隔离级别，每个级别会引发什么问题，mysql默认是哪个级别？

    从理论上来说，事务应该彼此完全隔离，以避免并发事务所导致的问题，然而，那样会对性能产生极大的影响，因为事务必须按顺序运行，在实际开发中，为了提升性能，事务会以较低的隔离级别运行，事务的隔离级别可以通过隔离事务属性指定。

    `事务的并发问题`

    - 脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据。

    - 不可重复读：事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。

    - 幻读：幻读解决了不重复读，保证了同一个事务里，查询的结果都是事务开始时的状态（一致性）。

      例如：事务T1对一个表中所有的行的某个数据项做了从“1”修改“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给了数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有跟没有修改一样，其实这行就是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。

    `小结`

    不可重复读和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或者删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。

    `事务的隔离级别`

    - 读未提交：另一个事务修改了数据，但尚未提交，而本事务中的SELECT会读到这些未被提交的数据脏读。
    - 不可重复读：事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。
    - 可重复读：在同一事务里，SELECT的结果是事务开始时时间点的状态，因此，同样的SELECT操作读到结果会是一致的。
    - 串行化：最高的隔离级别，在这个隔离级别下，不会产生任何异常，并发的事务，就像事务是在一个个按照顺序执行一样。

12. mysql索引的理解

    mysql索引使用的数据结构主要有B树索引和哈希索引。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择B树索引。

    mysql的B树索引使用的是B树种的B+树，但对于主要的存储引擎的实现方式是不同的。

    - `Mylsam`： B+树叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+树搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。
    - `InnoDB`：其数据文件本身就是索引文件。相比于`Mylsam`，索引文件和数据文件是分离的，其表数据文件本身就是按B+树组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key的数据表的主键，因此InnoDB表数据文件本身就是索引。这被称为“聚簇索引”。而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和`Mylsam`不同的地方。在根据主索引搜索时，直接找到Key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。

13. 说说自己对于mysql常见的两种存储引擎：`MyISAM`和`InnoDB`的理解

    `InnoDB`引擎：InnoDB引擎提供了对数据库acid事务的支持，并且还提供了行级锁和外键的约束，它的设计目标就是处理大数据容量的数据库系统。mysql运行的时候，InnoDB会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索，同时启动也比较慢，它是不会保存表的行数的，所以当进行select count() form table指令的时候，需要进行扫描全表。由于锁的粒度小，写操作是不会锁定表全表的，所以在并发度高的场景下使用会提升效率的。

    `MyISAM`引擎： mysql的默认引擎，但不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和`InnoDB`不同的是，`MyISAM`引擎是保存了表的行数，于是当进行select count() from table语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将`MyISAM`作为数据库引擎的首选。

14. 为什么索引能提高查询速度？

    mysql的基本存储结构是页(记录都存在页里边)：

    - 各个数据页可以组成一个双向链表
    - 每个数据页中的记录又可以组成一个单向链表
      - 每个数据页都会为存储在它里边的记录生成一个页目录，在通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录
      - 以其他列(非主键)作为搜索条件：只能从最小记录开始依次遍历单链表中的每条记录。

    所以说，如果我们写select * from user where indexname = 'xxx'这样没有进行任何优化的sql语句，默认会这样做：

    - 定位到记录所在的页：需要遍历双向链表，找到所在的页
    - 从所在的页内中查找相应的记录：由于不是根据主键查询，只能遍历所在页的单链表

    很明显，在数据量很大的情况下这样查找很很慢！这样的时间复杂度为o(n)。

    使用索引后，很明显，没有用索引我们是需要遍历双向链表来定位对应的页，现在通过“目录”就可以很快地定位到对应的页上了！(二分查找，时间复杂度近似为O(logn)

    其实底层数据结构就是B+树，B+树作为树的一种实现，能够让我们很快地查找出对应的记录。

15. mysql的默认事务隔离级别？
    - 读未提交：一个事务还没提交时，它做的变更就能被别的事务看到
    - 读提交：一个事务提交后，它做的变更才会被其他事务看到
    - 可重复读： 一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据时一致的，当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
    - 串行化：对于同一行记录，读写都会加锁，当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成才能继续执行。

16. 简述以下如何优化数据库？

    数据库的优化可以从四个方面来优化

    - `结构层`：web服务器采用负载均衡服务器，mysql服务器采用主从复制，读写分离
    - `储存层`：采用合适的存储引擎，采用三范式
    - `设计层`：采用分区分表，索引，表的字段采用合适的字段属性，适当的采用逆范式，开启mysql缓存
    - sql语句层：结果一样的情况下，采用效率高，速度快节省资源的sql语句执行

17. 简要说一下数据库范式？

    `第一范式`（1NF）：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。

    `第二范式`（2NF）：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。（在1NF基础上消除主属性对主键的部分函数依赖）

    `第三范式`（3NF）：任何非主属性不依赖与其它非主属性。（在2NF基础上消除传递依赖）

18. mysql索引是怎么实现的？

    索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。具体来说mysql中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是B+树实现的，B+树引擎的搜索效率，可以到达二分法的性能，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的。

19. 做过哪些mysql索引相关的优化？

    - 尽量使用主键查询：聚簇索引上存储了全部数据，相比普通索引查询，减少了回表的消耗
    - MySQL5.6之后引入了索引下推优化，通过适当的使用联合索引，减少回表判断的消耗
    - 若频繁查询某一列数据，可以考虑利用覆盖索引避免回表
    - 联合索引将高频字段放在最左边

20. 如何做Mysql的性能优化

    为搜索字段创建索引。

    避免使用select * ，列出需要查询的字段。

    垂直分割分表。

    选择正确的存储引擎。

21. 什么是`最左前缀原则`

    mysql中的索引可以以一定顺序引用多列，这种索引叫作联合索引。如User表的name和city加联合索引就是(name,city)，而最左前缀原则指的是，如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到。如下：

    ```my
    select * from user where name=xx and city=xx; //可以命中索引
    select * from user where name=xx; //可以命中索引
    select * from user where city=xx; //无法命中索引
    ```

    这里需要注意的是，查询的时候如果两个条件都用上了，但是顺序不同，如city=xx and name=xx，那么现在的查询引擎会自动优化为匹配联合索引的顺序，这样是能够命中索引的。

    由于最左前缀原则，在创建联合索引时，索引字段的顺序需要考虑字段去重之后的个数，较多的放前面。ORDER BY子句也遵循此规则。

## 数据库基础知识

1.  为什么要使用数据库

   - 数据保存在内存

     优点： 存取速度快

     缺点：数据不能永久保存

   - 数据保存在文件

     优点：数据永久保存

     缺点：速度比内存操作慢，频繁的IO操作；查询数据不方便

   - 数据保存在数据库
     - 数据永久保存
     - 使用SQL语句，查询方便效率高
     - 管理数据方便

2. 什么是SQL？

   结构化查询语言简称SQL，是一种数据库查询语言。

   作用：用于存取数据、查询、更新和管理关系数据库系统。

   什么是`MYSQL`?

   MySQL是一种关系型数据库管理系统，是Oracle旗下的产品。MySQL是最流行的关系型数据库管理系统之一，在WEB应用方面，MySQL是最好的RDBMS(Relational Database Management System,关系数据库管理系统)应用软件之一。java企业级开发中非常常用，因为MySQL是开源免费的，并且方便扩展。

3. 数据库三大范式是什么

   - 第一范式： 每一列都不可以再拆分。
   - 第二范式： 在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分
   - 第三范式： 在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。

   在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。

4. MySQL的binlog有几种录入格式？分别有什么区别？

   有三种格式，statement,row和mixed。

   - statement模式下，每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。
   - row级别下，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(如alter table)，因此这种模式的文件保存的信息太多，日志量太大。
   - mixed，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。

   此外，新版的MySQL中对row级别也做了一些优化，当表结构发生变化的时候，会记录语句而不是逐行记录。

5. MySQL存储引擎MyISAM与InnoDB区别

   存储引擎Storage engine：MySQL中的数据、索引以及其他对象是如何存储的，是一套文件系统的实现。

   常用的存储引擎有以下：

   - `InnoDB`引擎：InnoDB引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。
   - `MyIASM`引擎：不提供事务的支持，也不支持行级锁和外键。
   - `MEMORY`引擎：所有的数据都在内存中，数据的处理速度快，但是安全性不高。

6. `MyISAM`索引和`InnoDB`索引的区别？

   - `InnoDB`索引时聚簇索引，`MyISAM`索引是非聚簇索引。
   - `InnoDB`的主键索引的叶子节点存储着行数据，因此主键索引非常高效。
   - `MyISAM`索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。
   - `InnoDB`非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。

7.  `InnoDB`引擎的4大特性

   - 插入缓冲(insert buffer)
   - 二次写(double write)
   - 自适应哈希索引(ahi)
   - 预读(read ahead)

8. 存储引擎选择

   如果没有特别的需求，使用默认的Innodb即可。

   `MyISAM`： 以读写插入为主的应用程序，比如博客系统、新闻门户网站。

   `InnoDB`： 更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，支持事务和外键。比如OA自动化办公系统。

9. 索引

   索引时一种特殊的文件（InnoDB数据表上的索引是表空间一个组成部分），它们包含着对数据表里所有记录的引用指针。

   索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。

   更通俗的说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。索引时一个文件，它是要占据物理空间的。

10. 索引有哪些优缺点？

    - 索引的优点
      - 可以大大加快数据的检索速度，这也是创建索引的最主要的原因。
      - 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。

    - 索引的缺点
      - 时间方面： 创建索引和维护索引要耗费时间，具体的，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增、改、删的执行效率。
      - 空间方面： 索引需要占物理空间。

11. 索引的数据结构(b树，hash)

    索引的数据结构和具体存储引擎的实现有关，在MySQL中使用较多的索引有Hash索引，B+树索引等，而我们经常使用的InnoDB存储引擎的默认索引实现为：B+树索引。对于哈希表索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。

    - B树索引

      mysql通过存储引擎取数据，基本使用InnoDB，按照实现方式分，InnoDB的索引类型目前只有两种：B树索引和哈希索引。B树索引是Mysql数据库中使用最频繁的索引类型，基本所有存储引擎都支持B树索引。通常我们说的索引不出意外指的就是B树索引。

    - 查询方式：

      - 主键索引区：PI（关联保存的数据地址）按主键查询
      - 普通索引区：si（关联id地址，然后再到达上面的地址）所以按主键查询，速度最快

    - B+tree性质：

      - n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。
      - 所有的叶子结点中包含了全部关键字的信息，及指向这些关键字记录的指针，且叶子结点本身以关键字的大小而大顺序链接。
      - 所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。
      - B+树中，数据对象的插入和删除仅在叶结点上进行。
      - B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶结点。

    - 哈希索引

      简要说下，类似于数据结构中简单实现的HASH表(散列表)一样，当我们在mysql中用哈希索引时，主要就是通过hash算法(常见的hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法)，将数据库字段数据转换成定长的hash值，与这条数据的行指针一并存入hash表的对应位置；如果发生hash碰撞(两个不同关键字的hash值相同)，则在对应hash键下以链表形式存储。

12. 索引的基本原理

    索引用来快速的寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。

    索引原理很简单，就是把无序的数据变成有序的查询。

    1. 把创建了索引的列的内容进行排序
    2. 对排序结果生成倒排表
    3. 在倒排表内容上拼上数据地址链
    4. 在查询的时候，先拿到倒排表内容，在取出数据地址链，从而拿到具体数据

13. 索引算法有哪些？

    索引算法有BTree算法和Hash算法

    - BTree算法

      BTree算法是最常用的mysql数据库索引算法，也是mysql默认的算法。因为它不仅可以被用在=,>,>=,<,<=和between这些比较操作符上，而且还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量，例如：

      ```mysql
      --只要它的查询条件是一个不以通配符开头的常量
      select * from user where name like 'jack%';
      --如果一通配符开头，或者没有使用常量，则不会使用索引，例如：
      select * from user where name like '%jack';
      ```

    - Hash算法

      Hash Hash索引只能用于对等比较，例如=,<=>操作符。由于是一次定位数据，不像BTree索引需要从根节点到枝节点，最后才能访问到页节点这样多次IO访问，所以检索效率远高于BTree索引。

14. 索引设计原则？

    - 适合索引的列是出现在where子句中的列，或者连接子句中的指定的列
    - 基数较小的类，索引效果较差，没有必要在列建立索引
    - 使用短索引，如果对长字符列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间
    - 不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。

15. 创建索引的原则

    索引虽好，但也不是无限制的使用，最好符合以下几个原则

    - 最左前缀匹配原则，组合索引非常重要的原则，Mysql会一直向右匹配直到遇到范围查询(>,<,between,like)就停止匹配，比如a =1 and b = 2 and c >3 and d > 4 如果建立(a,b,c,d)顺序索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
    - 较频繁作为查询条件的字段才去创建索引
    - 更新频繁字段不适合创建索引
    - 若是不能有效区分数据的列不合适做索引列
    - 定义有外键的数据列一定要建立索引
    - 对于那些查询中很少涉及的列，重复值比较多的列不要建立索引
    - 对于定义为text、image和bit的数据类型的列不要建立索引

16. 创建索引时需要注意什么？

    - 非空字段：应该指定列为NOT NULL，除非你想存储NULL。在Mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；
    - 取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多的离散程度高；
    - 索引字段越小越好：数据库的数据存储以页为存储的数据越多一次IO操作获取的数据越大效率越高。

17. 使用索引查询一定能提高查询的性能吗？为什么

    通常，通过索引查询数据比全表扫描要快，但是我们也必须注意到它的代价。

    - 索引需要空间来存储，也需要定期维护，每当有记录在表中增减或索引列被修改时，索引本身也会被修改。这意味着每条记录的INSERT, DELETE,UPDATE将为此付出4，5次的磁盘IO。因为索引需要额外的存储空间和处理，那些不必要的索引反而会使用查询反应时间变慢。使得索引查询不一定能提高查询性能，索引范围查询(INDEX RANGE SCAN)适用于两种情况：
      - 基于一个范围的检索，一般查询返回结果集小于表中记录数的30%
      - 基于非唯一性索引的检索

18. 什么是最左前缀原则？什么是最左匹配原则

    - 顾名思义，就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。
    - 最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>,<,between,like)就停止匹配，比如a =1 and b =2 and c >3 and d =4如果建立(a,b,c,d)顺序索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
    - =和in 可以乱序，比如a =1 and b =2 and c = 3建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式

19. B树和B+树的区别

    在B树中，你可以将键和值存放在内部节点和叶子节点；但在B+树中，内部节点都是键，没有值，叶子节点同时存放键和值。

    B+树的叶子节点有一条链相连，而B树的叶子节点各自独立。

20. 数据库为什么使用B+树而不是B树

    - B树只适合随机检索，而B+树同时支持随机检索和顺序检索；
    - B+树空间利用率更高，可减少IO次数，磁盘读写代价更低。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。这样的话，索引查找过程中就要产生磁盘IO消耗。B+树的内部节点并没有指向关键字具体信息的指针，只是作为索引使用，其内部节点比B树小，盘块能容纳的结点中关键字数量更多，一次性读入内存中可以查找的关键字也就越多，相对的，IO读写次数也就降低了，而IO读写次数是影响索引效率的最大因素；
    - B+树的查询效率更加稳定。B树搜素有可能会在非叶子节点结束，越靠近根节点的记录查找时间越短，只要找到关键字即可确定记录的存在，其性能等价于在关键字全集内做一次二分查找。而在B+树中，顺序检索比较明显，随机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径长度相同，导致每一个关键字的查询效率相当。
    - B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。B+树的叶子节点使用指针顺序连接在一起，只要遍历叶子节点就可以实现整棵树的遍历，而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作。
    - 增删文件节点时，效率更高，因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率。

21. 什么聚簇索引？何时使用聚簇索引与非聚簇索引

    - 聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据
    - 非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），内存中直接搜索索引，然后通过索引找到磁盘相应的数据，这也就是为什么索引不在key_buffer命中时，速度慢的原因

    澄清一个概念：innodb中，在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二分查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值

## 事务

1. 什么是数据库事务？

   事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。

2. 事务的四大特性

   - 原子性：事务是最小的执行单位，不允许分割。事务是原子性确保动作要么全部完成，要么完全不起作用；
   - 一致性：执行事务前后，数据保存一致，多个事务对同一个数据读取的结果是相同的；
   - 隔离性：并发访问数据时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库时独立的；
   - 持久性：一个事务被提交后，它对数据库中数据的改变时持久的，即使数据库发生故障也不应该对其有任何影响。

3. 什么是脏读？幻读？不可重复读？

   - 脏读： 某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。
   - 不可重复读：在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。
   - 幻读：在一个事务的两次查询中数据不一致。

4. SQL标准定义了四个隔离级别：

   - 读未提交： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。
   - 读取已提交：允许读取并发事务已经提交的事务，可以阻止脏读，但是幻读和不可重复读仍可能发生。
   - 可重复读：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
   - 可串行化： 最高隔离级别，完全服从ACID的隔离级别。所有事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。

   事务隔离机制的实现基于锁机制的并发调度。其中并发调度使用的是MVVC（多版本并发控制），通过保存修改的就版本信息来支持并发一致性读和回滚等特性。

   因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是读取提交；但是你要知道InnoDB存储引擎默认使用可重读，并不会有任何性能损失。

   InnoDB存储引擎在分布式事务的情况下一般会用到可串行化隔离级别。

## 锁

1. 对mysql的锁了解吗

   当数据库有并发事务的时候，可能会产生数据的不一致，这时候需要一些机制来保证访问的次序，锁机制就是这样的一个机制。

   就像酒店的房间，如果大家随意进出，就会出现多人抢夺同一个房间的情况，而在房间上装上锁，申请到钥匙的人才可以入住并且将房间锁起来，其他人只有等他使用完毕才可以使用。

2. 隔离级别与锁的关系

   在读未提交的级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突。

   在读提交的级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁

   在可重复读级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。

   串行化是限制性最强的隔离级别，因为该级别锁定整个范围的键，并一直持有锁，直到事务完成。

3. 按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法

   在关系型数据库中，可以按照锁的粒度把数据库锁分为行级锁(InnoDB引擎)、表级锁(MyISAM引擎)和页级锁(BDB引擎)。

   `MyISAM和InnoDB存储引擎使用的锁`:

   - `MyISAM`采用表级锁(table - level locking)
   - `InnoDB`支持行级锁(row-level locking)和表级锁，默认为行级锁

   `行级锁`、`表级锁`和`页级锁`对比

   行级锁：行级锁是Mysql中锁粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁和排他锁。

   特点：开销大，加锁慢；会出现死锁；锁粒度最小，发生锁冲突的概率最低，并发度也最高。

   `表级锁`： 表级锁是mysql中锁粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分mysql引擎支持。最常使用的`MyISAM`与`InnoDB`都支持表级锁定。表级锁定分为表共享读锁(共享锁)与表独占写锁(排他锁)。

   特点：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。

   `页级锁` 页级锁是mysql中锁粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。

   特点：开销和加锁时间介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般。

4. 从锁的类别上分Mysql都有哪些锁呢？像上面那样子进行锁定岂不是有点阻碍并发效率

   从锁类别上来讲，有共享锁和排他锁。

   共享锁：又叫读锁。当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。

   排他锁：又叫做写锁。当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥![img](file:///C:\Users\ADMINI~1\AppData\Local\Temp\SGPicFaceTpBq\531100\A67DC29D.gif)

5. MySql中InnoDB引擎的行锁是怎么实现的？

   InnoDB是基于索引来完成行锁

   例如：select * from tab_with_index where id = 1 for update;

   for update 可以根据条件来完成行锁锁定，并且id是有索引键的列，如果id不是索引键那么InnoDB将完成表锁，并发将无从谈起。

6. 什么是死锁？怎么解决？

   死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。

   常见的的解决死锁的方法：

   - 如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。
   - 在同一事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率。
   - 对于非常容易产生死锁的业务部分，可以尝试使用升级锁定粒度，通过表级锁来减少死锁产生的概率

   如果业务处理不好可以用分布式事务锁或者使用乐观锁

7. 数据库的乐观锁和悲观锁是什么？怎么实现的？

   数据库管理系统中的并发控制的任务是确保多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。

   - 悲观锁： 假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制
   - 乐观锁： 假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：一般会使用版本号机制或者CAS算法实现。

8. 两种锁的使用场景

   从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下(多读场景)，即冲突真的很少发生的时候，这样可以省去锁的开销，加大了系统的整个吞吐量。

   但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁比较合适。

9. 存储过程与函数

   什么是存储过程？有哪些优缺点？

   存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需要创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。

   优点

   - 存储过程是预编译的，执行效率高。
   - 存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。
   - 安全性高，执行存储过程需要有一定权限的用户。
   - 存储过程可以重复使用，减少数据库开发人员的工作量。

   缺点

   - 调试麻烦，但是用PL/SQL Developer调试很方便，弥补这个缺点
   - 移植问题，数据库端代码当然是与数据库相关的。但是如果是做工程型项目，基本不存在移植问题。
   - 重新编译问题，因为后端代码是运行前编译的，如果带有引用关系的对象发生改变时，受影响的存储过程、包将需要重新编译(不过也可以设置成运行时刻自动编译)。
   - 如果在一个程序系统中大量的使用存储过程，到程序交付使用的时候随着用户需求的增加会导致数据结构的变化，接着就是系统的相关问题了，最后如果用户想维护系统可以说是很难很难、而且代价是空前的，维护起来更麻烦。

10. 什么是视图？以及视图的使用场景有哪些？

    - 视图是一种虚拟的表，具有和物理表相同的功能，可以对视图进行增、改、查操作，视图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。
    - 只暴露部分字段给访问者，所有就建一个虚表，就是视图。
    - 查询的数据来源于不同的表，而查询者希望以统一的方式查询，这样也可以建立一个视图，把多个视图查询结果联合起来，查询者只需要直接从视图中获取数据，不必考虑数据来源于不同表带来的差异

## SQL优化

​	如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到？或者说怎么才可以知道这条语句运行很慢的原因？

​	对于低性能的SQL语句的定位，最重要也是最有效的方法就是使用执行计划，MySQL提供了explain命令来查看语句的执行计划。我们知道，不管是哪种数据库，或者是哪种数据库引擎，在对一条SQL语句进行执行的过程中都会相关的优化，对于查询语句，最重要的优化方式就是使用索引。而执行计划，就是显示数据库引擎对于SQL语句的执行的详细情况，其中包含了是否使用索引，使用什么索引，使用的索引的相关信息等。



## redis

1. 什么是Redis

   简单来说，redis就是一个数据库，不过与传统数据库不同的是redis的数据是存在内存中的，所以读写速度非常快，因此redis被广泛应用于缓存方向。另外，redis也经常用来做分布式锁。redis提供了多种数据类型来支持不同的

2. 为什么要用redis？为什么要用缓存？

   主要从“高性能”和“高并发”这两点来看待这个问题。

   - 高性能

     假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中对应数据改变之后，同步改变缓存中相应的数据即可。

   - 高并发

     直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不是经过数据库。

3. 为什么要用redis而不用map/guava做缓存？

   缓存分为本地缓存和分布式缓存。以java为例，使用自带的map或者guava实现的本地缓存，最主要的特点是轻量以及快速，生命周期随着jvm的销毁而结束，并且在实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。

   使用redis或memcached之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保存redis或memcached服务的高可用，整个程序架构上较为复杂。

4. redis的线程模型是怎么样的？

   redis内部使用文件事件处理器`file event handler`，这个文件事件处理器是单线程的，所以redis才叫做单线程模型。它采用IO多路复用机制同时监听多个socket，根据socket上的事件来选择对应事件处理器进行处理。

   文件事件处理器的结构包含4个部分：

   - 多个socket
   - IO多路复用程序
   - 文件事件分派器
   - 事件处理器(连接应答处理器，命令请求处理器，命令回复处理器)

   多个socket可能会并发产生不同的操作，每个操作对应不同的文件事件，但是IO多路复用程序会监听多个socket，会将socket产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。

5. redis和memcached的区别？

   - 存储方式不同：memcache把数据全部存在内存中，断电后会挂掉，数据不能超过内存大小；redis有部分存在硬盘上，这样能保证数据的持久性。
   - 数据支持类型：memcache对数据类型支持相对简单；redis有复杂的数据类型。
   - 使用底层模型不同：它们之间底层实现方式，以及与客户端之间通信的应用协议不一样，redis自己构建了vm机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。value值大小不同：redis最大可以达到1jb;memcache只有1mb。

   对于redis和memcached总结下面四点。

   - redis支持更丰富的数据类型(支持更复杂的应用场景)：redis不仅仅支持简单的k/v类型的数据，同时还提供list,set,zset,hash等数据结构的存储。memcache支持简单的数据类型，string。
   - redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用，而memecache把数据全部存在内存中。
   - 集群模式：memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是redis目前是原生支持cluster模式的。
   - memcached是多线程，非阻塞IO复用的网络模型；redis使用单线程的多路IO复用模型。

6.  redis常见数据结构以及使用场景分析？

   redis提供了5种数据结构，每一种数据结构有各种的使用场景。

   - String字符串

     字符串类型是redis最基础的数据结构，首先键都是字符串类型，而且其他几种数据结构都在字符串类型基础上构建的，我们常使用的set key value 命令就是字符串，常用在缓存、计数、共享Session、限速等。

   - Hash哈希

     在redis中，哈希类型是指键值本身又是一个键值对结构，形如value={{field1,value1},...}，添加命令：hset key field value。哈希可以用来存放用户信息，比如实现购物车

   - List列表

     列表(list)类型是用来存储多个有序的字符串。可以做简单的消息队列的功能。另外，可以利用lrang命令，做基于redis的分页功能，性能极佳，用户体验好。

   - Set集合

     集合(set)类型也是用来保存多个字符串元素，但和列表类型不一样的是，集合中不允许有重复元素，并且集合中的元素是无序的，不能通过索引下标获取元素。利用Set的交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。

   - Sorted Set 有序集合

     Sorted Set多了一个权重参数Score，集合中的元素能够按Score进行排列。可以做排行榜应用，去TOP N操作

7. `mysql`里有2000w数据，`redis`中只存20w的数据，如何保证redis中的数据都是热点数据？

   `redis`提供6种数据淘汰策略：

   - `volatile-lru`：从已设置过期时间的数据集(server.db[i].expires)中挑选最近最少使用的数据淘汰
   - `volatile-ttl`：从已设置过期时间的数据集(server.db[i].expires)中挑选将要过期的数据淘汰
   - `volatile-random`：从已设置过期时间的数据集(server.db[i].expires)中任意选择数据淘汰
   - `allkeys-lru`：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的Key(这个是最常用的)
   - `allkeys-random`：从数据集(server.db[i].dict)中任意选择数据淘汰
   - `no-eviction`：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会保错。

   4.0版本后增加以下两种：

   - `volatile-lfu`：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰
   - `allkeys-lfu`：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的key

8. 单线程的redis为什么这么快？

   redis有多快？官方给出的答案是读写速度10万/秒，如果说这是在单线程情况下跑出来的成绩，你会不会惊讶？为什么单线程的redis速度这么快？

   `纯内存操作`：redis是完全`基于内存`的，所以读写效率非常高，当然redis存在持久化操作，在持久化操作是都是fork子进程和利用linux系统的页缓存技术来完成，并不会影响redis的性能。

   `单线程操作`：单线程并不是坏事，单线程可以避免了频繁的上下文切换，频繁的上下文切换也会影响性能的。

   合理高效的数据结构采用了非阻塞IO多路复用机制：多路IO复用模型是利用select、poll、epoll可以同时监察多个流的IO事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有IO事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流(epoll是只轮询那些真正发出了事件的流)，并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。

10. 解释下什么是池化设计思想。什么是数据库连接池？为什么需要数据库连接池？

    池话设计应该不是一个新名词。我们常见的如java线程池、jdbc连接池、redis连接池等就是这类设计的代表实现。这种设计会初始预设资源，解决的问题就是抵消每次获取资源的消耗，如创建线程的开销，获取远程连接的开销等。就好比你去食堂打饭，打饭的大妈会先把饭盛好几份放那里，你来了就直接拿着饭盒加菜即可，不用再临时又盛饭又打菜，效率就高了。除了初始化资源，池化设计还包括如下特征：池子的初始值、池子的活跃值、池子的最大值等，这些特征可以直接映射到java线程池和数据库连接池的成员属性中。

    数据库连接本质就是一个socket的连接。数据库服务端还要维护一些缓存和用户权限信息之类的，所以占用了一些内存。我们可以把数据库连接池是看做维护的数据库连接的缓存，以便将来需要对数据库的请求时可以重用这些连接。为每个用户打开和维护数据库连接，尤其是对动态数据库驱动的网站应用程序的请求，既昂贵又浪费资源。在连接池中，创建连接后，将其放置在池中，并再次使用它，因此不必建立新的连接。如果使用了所有连接，则会建立一个新连接将其添加到池中。连接池还减少了用户必须等待建立与数据库的连接时间。

11. redis为什么是单线程？

    因为cpu不是redis的瓶颈，redis的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且cpu又不会成为瓶颈，那就顺理成章地采用单线程的方案了。关于redis的性能，官方网站也有，普通笔记本轻松处理每秒几十万请求。而且单线程并不代表就慢，nginx和node.js也都是高性能单线程的代表。

## 计算机网路

1. OSI(Open System Interconnection/Reference Model)七层协议

   自下而上依次为：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层

   - 物理层

     激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性。该层为上层提供了一个传输数据可靠的物理媒体。简单的说，物理层确保原始的数据可在各种物理媒体上传输。物理层记住两个重要的设备名称，中继器和集线器。

   - 数据链路层

     数据链路层在物理层提供的服务的基础上向网络层提供服务，其最基本的服务是将源自网路层来的数据可靠地传输到相邻节点的目标机网路层。

     有关数据链路层的重要知识点：

     1. 数据链路层为网络层提供可靠的数据传输；
     2. 基本数据单位为帧；
     3. 主要的协议：以太网协议；
     4. 重要的设备：交换机。

   - 网络层

     网络层的目的是实现两个端系统之间的数据透明传送，具体功能包括寻址和路由选择、连接的建立、保存和终止等。它提供的服务使传输层不需要了解网络中的数据传输和交换技术。如果你想用尽量少的词来记住网络层，那就是`路径选择、路由及逻辑寻址`。

     网络层中涉及众多的协议，其中包括最重要的协议，即TCP/IP的核心协议---`IP协议`。

     IP协议非常简单，仅仅提供不可靠、无连接的传送服务。IP协议的主要功能有：无连接数据报传输、数据报路由选择和差错控制。与IP协议配套使用实现其功能的还有地址解析协议ARP、逆地址解析协议RARP、因特网报文协议ICMP、因特网组管理协议IGMP。

     有关网络层的的重点为：

     - 网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能；
     - 基本数据单位为IP数据报；
     - 包含的主要协议：
       - IP协议(Internet Protocol，因特网互联协议)；
       - ICMP协议(Internet Control Message Protocol ,因特网控制报文协议)；
       - ARP协议(Address Resolution Protocol，地址解析协议)；
       - RARP(Reverse Address Resolution Protocol,逆地址解析协议)。
     - 重要的设备：路由器

   - 传输层

     第一个端到端，即主机到主机的层次。传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输。此外，传输层还要处理端到端的差错控制和流量控制问题。

     传输层的任务是根据通信子网的特性，最佳的利用网络资源，为两个端系统的会话层之间，提供建立、维护和取消传输连接的功能，负责端到端的可靠数据传输。在这一层，信息传送的协议数据单元称为段或报文。

     网络层只是根据网路地址将源结点发出的数据包传送到目的结点，而传输层则负责将数据可靠地传送到相应的端口。

     有关网络层的重点：

     1. 传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输以及端到端的差错控制和流量控制问题；
     2. 包含的主要协议：TCP协议、UDP协议；
     3. 重要设备：网关。

   - 会话层

     会话层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。

   - 表示层

     表示层对上层数据或信息进行交换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。

   - 应用层

     为操作系统或网路应用程序提供访问网络服务的接口。

     会话层、表示层和应用层重点：

     1. 数据传输基本单位为报文；
     2. 包含的主要协议：FTP(文件传送协议)、Telnet(远程登录协议)、DNS(域名解析协议)、SMTP(邮件传送协议)、POP3协议(邮局协议)、HTTP协议(Hyper Text Transfer Protocol)；

2. TCP/IP四层模型

   网络接口层、网络层、传输层、应用层

3. TCP/IP五层模型

   物理层、数据链路层、网路层、传输层、应用层

4. HTTP

   HTTP协议定义了浏览器（万维网客户今进程）怎么样向万维网服务器请求万维网文档，以及服务器怎么样把文档传送给浏览器。

   具体过程

   - 浏览器分析URL
   - 浏览器向DNS请求解析IP地址
   - DNS解析出IP地址
   - 浏览器与服务器建立TCP连接
   - 浏览器发出取文件命令
   - 服务器响应
   - 释放TCP连接
   - 浏览器显示

   HTTP协议是无状态的，但是在实际工作中，一些万维网站点常常希望能够识别用户。

   Cookie是存储在用户主机中的文本文件，记录一段时间某用户的访问记录。

   HTTP采用TCP作为运输层协议，但HTTP协议本身是无连接的（通信双方咋交换HTTP报文之间不需要先建立HTTP连接）

## 23中设计模式

- 单例模式
- 观察者模式
- 工厂模式
- 模板模式
- 代理模式
- 建造者模式
- 责任链模式
- 装饰者模式